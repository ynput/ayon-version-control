{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#version-control-addon","title":"Version control addon","text":"<p>This addon tries to implement generic API for various version control system.</p> <p>Currently contains WIP implementation of Perforce, but there might be more in the future which should follow same API methods.</p> <p>Implementation tries to use only single dependency <code>p4python</code> which is binary dependent on version of python used. Which might be different in different DCCs, different versions of Unreal etc.</p> <p>To mitigate need of having binary compatible <code>p4python</code> libraries addon currently implements REST api to run p4 commands  only on separate webserver started by AYON Tray which contains <code>p4python</code> library installed via dependency package and  REST stub class which might be used in each DCC that has <code>requests</code> library.</p>"},{"location":"index.html#configuration-of-connection-to-perforce-server","title":"Configuration of connection to Perforce server","text":"<p>Addons offers configuration of credentials to P4 server with username and password on multiple levels via Studio(single credentials), Project (credentials different per project)  or Site settings(credentials different per artist.)</p>"},{"location":"index.html#perforce-workspace","title":"Perforce workspace","text":"<p>It is expected that P4 workspaces would be setup and existing on artists machines. Each artist then only  provides path to their locally accessible P4 workspace folder in Site Settings.</p>"},{"location":"index.html#main-functionalities-for-perforce","title":"Main functionalities for Perforce","text":"<p>This addons contains two main  functionality for slightly different use cases: - create separate version controlled streams from AYON of published products in Perforce - help with Deadline rendering of Unreal projects with Perforce</p> <p>It is expected that majority work for Perforce with Unreal project files are done with official Perforce tools like <code>P4V</code> or command line utility. Neither of those are distributed by addon and it is required for IT department to install/configure them.</p>"},{"location":"index.html#commits-to-perforce","title":"Commits to Perforce","text":"<p>This approach allows to copy version control not only in AYON, where each publish results in new version of published product, but committing this version directly to Perforce. </p> <p>That way versions of particular product are separately kept in Perforce, from which ordinary Perforce tools could be used (P4V) to pull latest version of published product.</p> <p>Profiles could be used to limit which published products should be committed to Perforce.</p> <p>As Perforce controlled product doesn't contain version name directly in its name nor path, additional AYON template must be configured in Project's Anatomy &gt; Templates.</p> <p>New template must follow <code>Hero template</code> - https://ayon.ynput.io/docs/artist_concepts/#hero-version approach, <code>Hero</code> template could beu used directly too (if it is matching required folder structure in Perforce)</p>"},{"location":"index.html#support-for-unreal-and-deadline","title":"Support for Unreal and Deadline","text":"<p>The other workflow is to help rendering Unreal from Perforce on Deadline rendering farm.</p> <p>In this use case there is an expection that multiple artists are working on Unreal project with standard utilization of P4 or Unreal P4 official plugin to checkout/commit any modifications to Unreal project to Perforce.</p> <p>Addons offers additional possibility to mark current stage of Unreal project, eg. latest commit/changelist, as 'published' and store its metadata in AYON for possible future workflows and enhancements.</p> <p>New additional mini tool is provided for artists before they open Unreal via AYON launcher which allows them to  <code>P4 sync</code> (not <code>checkout</code> - that would lock the files) to any previously published version before Unreal is actually opened.</p> <p>This marker, or tag, points to commit/changelist and could be pushed to Deadline integration where Deadline syncs to this particular commit before rendering. </p> <p>This requires to have AYON integration to Deadline installed. Please check https://ayon.ynput.io/docs/addon_deadline_admin for more details.</p> <p>Usage of Perforce in Deadline submissions could be controlled by toggling on/off of automatically created instance of  <code>changelist_metadata</code> product type in AYON Publisher.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>version_control<ul> <li>addon</li> <li>backends<ul> <li>abstract</li> <li>perforce<ul> <li>api<ul> <li>p4_dcc</li> <li>p4_errors</li> <li>p4_offline</li> </ul> </li> <li>backend</li> <li>convert_to_py2_annotations</li> <li>rest_routes</li> </ul> </li> <li>undefined</li> </ul> </li> <li>changes_viewer<ul> <li>abstract</li> <li>control</li> <li>model</li> <li>widgets</li> <li>window</li> </ul> </li> <li>launch_hooks<ul> <li>perforce<ul> <li>pre_load_sync_project</li> </ul> </li> </ul> </li> <li>lib</li> <li>perforce_triggers<ul> <li>change_submit_trigger</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>unreal<ul> <li>changelist_metadata</li> </ul> </li> </ul> </li> <li>publish<ul> <li>collect_latest_changelist</li> <li>collect_version_control</li> <li>collect_version_control_login</li> <li>extract_change_list_info</li> <li>integrate_perforce</li> <li>validate_stream</li> <li>validate_workspace</li> </ul> </li> </ul> </li> <li>rest<ul> <li>communication_server</li> <li>perforce<ul> <li>rest_api</li> <li>rest_stub</li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>main</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/version_control/index.html","title":"version_control","text":"<p>Package for interfacing with version control systems</p>"},{"location":"autoapi/client/version_control/index.html#client.version_control.VersionControlAddon","title":"<code>VersionControlAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>ITrayService</code>, <code>IPluginPaths</code></p> Source code in <code>client/version_control/addon.py</code> <pre><code>class VersionControlAddon(AYONAddon, ITrayService, IPluginPaths):\n\n    label = \"Version Control\"\n    name = \"version_control\"\n    version = __version__\n\n    # _icon_name = \"mdi.jira\"\n    # _icon_scale = 1.3\n    webserver = None\n    active_version_control_system = None\n\n    # Properties:\n    @property\n    def name(self):\n        # type: () -&gt; str\n        return \"version_control\"\n\n    @property\n    def label(self):\n        # type: () -&gt; str\n        return f\"Version Control: {self.active_version_control_system.title()}\"\n\n    # Public Methods:\n    def initialize(self, settings):\n        # type: (dict[str, Any]) -&gt; None\n        assert self.name in settings, (\n            \"{} not found in settings - make sure they are defined in the defaults\".format(self.name)\n        )\n        vc_settings = settings[self.name]  # type: dict[str, Any]\n        active_version_control_system = vc_settings[\"active_version_control_system\"]  # type: str\n        self.active_version_control_system = active_version_control_system\n        enabled = vc_settings[\"enabled\"]  # type: bool\n        self.set_service_running_icon() if enabled else self.set_service_failed_icon()\n\n    def get_global_environments(self):\n        # return {\"ACTIVE_VERSION_CONTROL_SYSTEM\": self.active_version_control_system}\n        return {}\n\n    def get_connection_info(\n        self,\n        project_name: str,\n        project_settings: dict = None,\n        context: WorkspaceProfileContext = None\n    ):\n        if not project_settings:\n            project_settings = get_project_settings(project_name)\n\n        version_settings = project_settings[\"version_control\"]\n        local_setting = version_settings[\"local_setting\"]\n\n        workspace_name = None\n        filtering_criteria = {\n            \"folder_paths\": None,\n            \"task_names\": None,\n            \"task_types\": None\n        }\n        if context:\n            filtering_criteria = {\n                \"folder_paths\": context.folder_paths,\n                \"task_names\": context.task_names,\n                \"task_types\": context.task_types\n            }\n        profile = filter_profiles(\n            local_setting[\"workspace_profiles\"],\n            filtering_criteria,\n            logger=self.log\n        )\n        if profile:\n            workspace_name = profile[\"workspace_name\"]\n\n        return {\n            \"host\": version_settings[\"host_name\"],\n            \"port\": version_settings[\"port\"],\n            \"username\": local_setting[\"username\"],\n            \"password\": local_setting[\"password\"],\n            \"workspace_name\": workspace_name\n        }\n\n    def sync_to_version(self, conn_info, change_id):\n        from version_control.rest.perforce.rest_stub import \\\n            PerforceRestStub\n\n        PerforceRestStub.login(host=conn_info[\"host\"],\n                               port=conn_info[\"port\"],\n                               username=conn_info[\"username\"],\n                               password=conn_info[\"password\"],\n                               workspace=conn_info[\"workspace_dir\"])\n        PerforceRestStub.sync_to_version(\n            f\"{conn_info['workspace_dir']}/...\", change_id)\n        return\n\n    def tray_exit(self):\n        if self.enabled and \\\n                self.webserver and self.webserver.server_is_running:\n            self.webserver.stop()\n\n    def tray_init(self):\n        return\n\n    def tray_start(self):\n        if self.enabled:\n            from version_control.rest.communication_server import WebServer\n            self.webserver = WebServer()\n            self.webserver.start()\n\n    def get_plugin_paths(self):\n        return {}\n\n    def get_create_plugin_paths(self, host_name):\n        if host_name != \"unreal\":\n            return []\n        return [\"{}/plugins/create/unreal\".format(VERSION_CONTROL_ADDON_DIR)]\n\n    def get_publish_plugin_paths(self, host_name):\n        return [os.path.join(VERSION_CONTROL_ADDON_DIR,\n                             \"plugins\", \"publish\")]\n\n    def get_launch_hook_paths(self, _app):\n        \"\"\"Implementation for applications launch hooks.\n\n        Returns:\n            (str): full absolute path to directory with hooks for the module\n        \"\"\"\n\n        return os.path.join(VERSION_CONTROL_ADDON_DIR, \"launch_hooks\",\n                            self.active_version_control_system)\n</code></pre>"},{"location":"autoapi/client/version_control/index.html#client.version_control.VersionControlAddon.get_launch_hook_paths","title":"<code>get_launch_hook_paths(_app)</code>","text":"<p>Implementation for applications launch hooks.</p> <p>Returns:</p> Type Description <code>str</code> <p>full absolute path to directory with hooks for the module</p> Source code in <code>client/version_control/addon.py</code> <pre><code>def get_launch_hook_paths(self, _app):\n    \"\"\"Implementation for applications launch hooks.\n\n    Returns:\n        (str): full absolute path to directory with hooks for the module\n    \"\"\"\n\n    return os.path.join(VERSION_CONTROL_ADDON_DIR, \"launch_hooks\",\n                        self.active_version_control_system)\n</code></pre>"},{"location":"autoapi/client/version_control/addon.html","title":"addon","text":""},{"location":"autoapi/client/version_control/addon.html#client.version_control.addon.VersionControlAddon","title":"<code>VersionControlAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>ITrayService</code>, <code>IPluginPaths</code></p> Source code in <code>client/version_control/addon.py</code> <pre><code>class VersionControlAddon(AYONAddon, ITrayService, IPluginPaths):\n\n    label = \"Version Control\"\n    name = \"version_control\"\n    version = __version__\n\n    # _icon_name = \"mdi.jira\"\n    # _icon_scale = 1.3\n    webserver = None\n    active_version_control_system = None\n\n    # Properties:\n    @property\n    def name(self):\n        # type: () -&gt; str\n        return \"version_control\"\n\n    @property\n    def label(self):\n        # type: () -&gt; str\n        return f\"Version Control: {self.active_version_control_system.title()}\"\n\n    # Public Methods:\n    def initialize(self, settings):\n        # type: (dict[str, Any]) -&gt; None\n        assert self.name in settings, (\n            \"{} not found in settings - make sure they are defined in the defaults\".format(self.name)\n        )\n        vc_settings = settings[self.name]  # type: dict[str, Any]\n        active_version_control_system = vc_settings[\"active_version_control_system\"]  # type: str\n        self.active_version_control_system = active_version_control_system\n        enabled = vc_settings[\"enabled\"]  # type: bool\n        self.set_service_running_icon() if enabled else self.set_service_failed_icon()\n\n    def get_global_environments(self):\n        # return {\"ACTIVE_VERSION_CONTROL_SYSTEM\": self.active_version_control_system}\n        return {}\n\n    def get_connection_info(\n        self,\n        project_name: str,\n        project_settings: dict = None,\n        context: WorkspaceProfileContext = None\n    ):\n        if not project_settings:\n            project_settings = get_project_settings(project_name)\n\n        version_settings = project_settings[\"version_control\"]\n        local_setting = version_settings[\"local_setting\"]\n\n        workspace_name = None\n        filtering_criteria = {\n            \"folder_paths\": None,\n            \"task_names\": None,\n            \"task_types\": None\n        }\n        if context:\n            filtering_criteria = {\n                \"folder_paths\": context.folder_paths,\n                \"task_names\": context.task_names,\n                \"task_types\": context.task_types\n            }\n        profile = filter_profiles(\n            local_setting[\"workspace_profiles\"],\n            filtering_criteria,\n            logger=self.log\n        )\n        if profile:\n            workspace_name = profile[\"workspace_name\"]\n\n        return {\n            \"host\": version_settings[\"host_name\"],\n            \"port\": version_settings[\"port\"],\n            \"username\": local_setting[\"username\"],\n            \"password\": local_setting[\"password\"],\n            \"workspace_name\": workspace_name\n        }\n\n    def sync_to_version(self, conn_info, change_id):\n        from version_control.rest.perforce.rest_stub import \\\n            PerforceRestStub\n\n        PerforceRestStub.login(host=conn_info[\"host\"],\n                               port=conn_info[\"port\"],\n                               username=conn_info[\"username\"],\n                               password=conn_info[\"password\"],\n                               workspace=conn_info[\"workspace_dir\"])\n        PerforceRestStub.sync_to_version(\n            f\"{conn_info['workspace_dir']}/...\", change_id)\n        return\n\n    def tray_exit(self):\n        if self.enabled and \\\n                self.webserver and self.webserver.server_is_running:\n            self.webserver.stop()\n\n    def tray_init(self):\n        return\n\n    def tray_start(self):\n        if self.enabled:\n            from version_control.rest.communication_server import WebServer\n            self.webserver = WebServer()\n            self.webserver.start()\n\n    def get_plugin_paths(self):\n        return {}\n\n    def get_create_plugin_paths(self, host_name):\n        if host_name != \"unreal\":\n            return []\n        return [\"{}/plugins/create/unreal\".format(VERSION_CONTROL_ADDON_DIR)]\n\n    def get_publish_plugin_paths(self, host_name):\n        return [os.path.join(VERSION_CONTROL_ADDON_DIR,\n                             \"plugins\", \"publish\")]\n\n    def get_launch_hook_paths(self, _app):\n        \"\"\"Implementation for applications launch hooks.\n\n        Returns:\n            (str): full absolute path to directory with hooks for the module\n        \"\"\"\n\n        return os.path.join(VERSION_CONTROL_ADDON_DIR, \"launch_hooks\",\n                            self.active_version_control_system)\n</code></pre>"},{"location":"autoapi/client/version_control/addon.html#client.version_control.addon.VersionControlAddon.get_launch_hook_paths","title":"<code>get_launch_hook_paths(_app)</code>","text":"<p>Implementation for applications launch hooks.</p> <p>Returns:</p> Type Description <code>str</code> <p>full absolute path to directory with hooks for the module</p> Source code in <code>client/version_control/addon.py</code> <pre><code>def get_launch_hook_paths(self, _app):\n    \"\"\"Implementation for applications launch hooks.\n\n    Returns:\n        (str): full absolute path to directory with hooks for the module\n    \"\"\"\n\n    return os.path.join(VERSION_CONTROL_ADDON_DIR, \"launch_hooks\",\n                        self.active_version_control_system)\n</code></pre>"},{"location":"autoapi/client/version_control/lib.html","title":"lib","text":""},{"location":"autoapi/client/version_control/lib.html#client.version_control.lib.WorkspaceProfileContext","title":"<code>WorkspaceProfileContext</code>  <code>dataclass</code>","text":"<p>Data that could be used in filtering workspace name</p> Source code in <code>client/version_control/lib.py</code> <pre><code>@dataclass\nclass WorkspaceProfileContext:\n    \"\"\"Data that could be used in filtering workspace name\"\"\"\n    folder_paths: str\n    task_names: str\n    task_types: str\n</code></pre>"},{"location":"autoapi/client/version_control/version.html","title":"version","text":"<p>Package declaring AYON addon 'version_control' version.</p>"},{"location":"autoapi/client/version_control/backends/index.html","title":"backends","text":"<p>Package for interfacing with version control systems</p>"},{"location":"autoapi/client/version_control/backends/abstract.html","title":"abstract","text":""},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl","title":"<code>VersionControl</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for defining a version control interface.</p> Source code in <code>client/version_control/backends/abstract.py</code> <pre><code>class VersionControl(ABC):\n    \"\"\"\n    Base class for defining a version control interface.\n    \"\"\"\n\n    _default_change_list_description = \"Pyblish auto generated change list\"\n\n    def __init__(self):\n        super(VersionControl, self).__init__()\n\n        self._change_list_description = \"\"\n        self._settings = None\n\n    # Public Properties:\n    @property\n    def settings(self):\n        return self._settings\n\n    @property\n    def saved_change_list_descriptions(self):\n        try:\n            return self.settings.get_item(\"change_list_descriptions\")\n        except ValueError:\n            return {}\n\n    @property\n    def host_app_name(self):\n        # type: () -&gt; str\n        \"\"\"\n        # Property:\n        Get the name of the registerd host application\n        \"\"\"\n\n        return os.environ[\"AVALON_APP\"]\n\n    @property\n    def change_list_description_prefix(self):\n        # type: () -&gt; str\n        \"\"\"\n        # Property:\n        Get the prefix to be added to any given change list description.\n        It follows the following convention:\n        `[art][{parent}][{asset_name}][{task_type}][{task_name}]`\n\n        This provides tags for UnrealGameSync.\n\n        TODO: Have this be togglable via settings.\n        TODO: Have this definable via the template system.\n        \"\"\"\n\n        from openpype.pipeline import legacy_io\n\n        legacy_io.install()\n        project_name = legacy_io.Session[\"AVALON_PROJECT\"]  # type: str\n        asset_name = legacy_io.Session[\"AVALON_ASSET\"]  # type: str\n        task_name = legacy_io.Session[\"AVALON_TASK\"]  # type: str\n\n        project_entity = legacy_io.find_one({\"type\": \"project\", \"name\": project_name})\n        assert project_entity, (\"Project '{0}' was not found.\").format(project_name)\n\n        asset_entity = legacy_io.find_one(\n            {\"type\": \"asset\", \"name\": asset_name, \"parent\": project_entity[\"_id\"]}\n        )\n        assert asset_entity, (\"No asset found by the name '{0}' in project '{1}'\").format(\n            asset_name, project_name\n        )\n\n        data = asset_entity[\"data\"]\n\n        asset_tasks = data.get(\"tasks\") or {}\n        task_info = asset_tasks.get(task_name) or {}\n        task_type = task_info.get(\"type\") or \"\"\n        parents = data.get(\"parents\") or []\n        parent = \"[{}]\".format(parents[-1]) if parents else \"\"\n\n        return \"[Art]{p}[{an}][{tt}][{tn}]\".format(\n            p=parent, an=asset_name, tt=task_type, tn=task_name\n        )\n\n    @property\n    def cached_change_list_description(self):\n        # type: () -&gt; str\n        \"\"\"\n        # Property:\n        Get the currently cached change list description for the current host.\n        This will be the last description used, but only if the change list still\n        exists. If the change list exists, the cached description will be returned.\n        If the change list does not exists, the default change list description will\n        be returned.\n        \"\"\"\n\n        host_app_name = self.host_app_name\n        change_list_descriptions = (\n            self.saved_change_list_descriptions\n        )  # type: dict[str, str] | None\n        if not change_list_descriptions:\n            return self._default_change_list_description\n\n        change_list_description = change_list_descriptions.get(host_app_name)\n        if not change_list_description:\n            return self._default_change_list_description\n\n        if not self.get_existing_change_list(change_list_description):\n            return self._default_change_list_description\n\n        return change_list_description\n\n    @cached_change_list_description.setter\n    def cached_change_list_description(self, value):\n        # type: (str) -&gt; None\n        assert isinstance(\n            value, str\n        ), \"cached_change_list_description must be an instance of {0}. Got: {1} of type: {type(value)}\".format(\n            str, value\n        )\n\n        change_list_descriptions = self.saved_change_list_descriptions\n        change_list_descriptions[self.host_app_name] = value\n        change_list_descriptions = self.settings.set_item(\n            \"change_list_descriptions\", change_list_descriptions\n        )\n\n    @property\n    def save_file_decorator(self):\n        # type: () -&gt; Callable[[Callable[[str], str]], Callable[[str], str]]\n        return _save_file_decorator\n\n    @property\n    def open_file_decorator(self):\n        # type: () -&gt; Callable[[Callable[[str], str]], Callable[[str], str]]\n        return _open_file_decorator\n\n    @property\n    def change_list_description(self):\n        # type: () -&gt; str\n        \"\"\"\n        #Property:\n        The current change list comment, if one has been set.\n        This allows recovery of a change list comment if the publish process\n        fails or the user chooses not to submit the change list.\n        \"\"\"\n\n        _change_list_description = self._change_list_description\n        if not _change_list_description:\n            _change_list_description = self.cached_change_list_description\n\n        if not _change_list_description.startswith(\"[\"):\n            _change_list_description = \"{0} {1}\".format(\n                self.change_list_description_prefix, _change_list_description\n            )\n\n        self._change_list_description = _change_list_description\n\n        return _change_list_description\n\n    @change_list_description.setter\n    def change_list_description(self, value):\n        # type: (str) -&gt; None\n        assert isinstance(\n            value, str\n        ), \"change_list_description must be an instance of {0}. Got: {1} of type: {type(value)}\".format(\n            str, value\n        )\n        if value == self._change_list_description:\n            return\n\n        if not value.startswith(\"[\"):\n            value = value[1:] if value.startswith(\" \") else value\n            value = \"{0} {1}\".format(self.change_list_description_prefix, value)\n\n        self.cached_change_list_description = value\n        self._change_list_description = value\n\n    # Public Abstract Static Methods:\n    @staticmethod\n    @abstractmethod\n    def get_server_version(path):\n        # type: (T_P4PATH) -&gt; int\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def get_local_version(path):\n        # type: (T_P4PATH) -&gt; int\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def get_version_info(path):\n        # type: (T_P4PATH) -&gt; tuple[int | None, int | None]\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def get_files_in_folder_in_date_order(path, name_pattern=None, extensions=None):\n        # type: (T_P4PATH, str | None, Sequence[str] | None) -&gt; list[tuple[pathlib.Path, datetime.datetime]]\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def get_newest_file_in_folder(path, name_pattern=None, extensions=None):\n        # type: (T_P4PATH, str | None, Sequence[str] | None) -&gt; pathlib.Path | None\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def is_latest_version(path):\n        # type: (T_P4PATH) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def is_checkedout(path):\n        # type: (T_P4PATH) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def checked_out_by(path, other_users_only=False):\n        # type: (T_P4PATH, bool) -&gt; list[str] | None\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def exists_on_server(path):\n        # type: (T_P4PATH) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def sync_latest_version(path):\n        # type: (T_P4PATH) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def sync_to_version(path, version):\n        # type: (T_P4PATH, int) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def add(path, comment=\"\"):\n        # type: (T_P4PATH, str) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def add_to_change_list(path, comment):\n        # type: (T_P4PATH, str) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def checkout(path, comment=\"\"):\n        # type: (T_P4PATH, str) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def revert(path):\n        # type: (T_P4PATH) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def move(path, new_path, change_description=None):\n        # type: (T_P4PATH, T_P4PATH, str | None) -&gt; bool\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def get_existing_change_list(comment):\n        # type: (str) -&gt; dict | None\n        \"\"\"\n        Get an existing change list with the given comment.\n        \"\"\"\n\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def submit_change_list(comment):\n        # type: (str) -&gt; int | None\n        \"\"\"\n        Submit an existing change list with the given comment.\n        If no changelist exists with the given comment then\n        raise `ChangeListNotFoundError`\n        \"\"\"\n\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def update_change_list_description(comment, new_comment):\n        # type: (str, str) -&gt; bool\n        \"\"\"\n        Update the current change list's description to the given one.\n\n        If the change list is not found it should raise: `ChangeListNotFoundError`.\n\n        The implementation should also set `self.change_list_description = new_comment`\n        \"\"\"\n\n        raise NotImplementedError()\n\n    # Public Methods:\n    def is_prefix_auto_generated(self, comment=\"\"):\n        # type: (str) -&gt; bool\n        comment = comment or self.change_list_description\n        if not comment.startswith(\"[\"):\n            return False\n\n        description = comment.split(\"]\")[-1]\n        current_prefix = comment.replace(description, \"\")\n        auto_prefix = self.change_list_description_prefix\n        return current_prefix == auto_prefix\n</code></pre>"},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.cached_change_list_description","title":"<code>cached_change_list_description</code>  <code>property</code> <code>writable</code>","text":""},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.cached_change_list_description--property","title":"Property:","text":"<p>Get the currently cached change list description for the current host. This will be the last description used, but only if the change list still exists. If the change list exists, the cached description will be returned. If the change list does not exists, the default change list description will be returned.</p>"},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.change_list_description","title":"<code>change_list_description</code>  <code>property</code> <code>writable</code>","text":""},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.change_list_description--property","title":"Property:","text":"<p>The current change list comment, if one has been set. This allows recovery of a change list comment if the publish process fails or the user chooses not to submit the change list.</p>"},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.change_list_description_prefix","title":"<code>change_list_description_prefix</code>  <code>property</code>","text":""},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.change_list_description_prefix--property","title":"Property:","text":"<p>Get the prefix to be added to any given change list description. It follows the following convention: <code>[art][{parent}][{asset_name}][{task_type}][{task_name}]</code></p> <p>This provides tags for UnrealGameSync.</p> <p>TODO: Have this be togglable via settings. TODO: Have this definable via the template system.</p>"},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.host_app_name","title":"<code>host_app_name</code>  <code>property</code>","text":""},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.host_app_name--property","title":"Property:","text":"<p>Get the name of the registerd host application</p>"},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.get_existing_change_list","title":"<code>get_existing_change_list(comment)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Get an existing change list with the given comment.</p> Source code in <code>client/version_control/backends/abstract.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef get_existing_change_list(comment):\n    # type: (str) -&gt; dict | None\n    \"\"\"\n    Get an existing change list with the given comment.\n    \"\"\"\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.submit_change_list","title":"<code>submit_change_list(comment)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Submit an existing change list with the given comment. If no changelist exists with the given comment then raise <code>ChangeListNotFoundError</code></p> Source code in <code>client/version_control/backends/abstract.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef submit_change_list(comment):\n    # type: (str) -&gt; int | None\n    \"\"\"\n    Submit an existing change list with the given comment.\n    If no changelist exists with the given comment then\n    raise `ChangeListNotFoundError`\n    \"\"\"\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/version_control/backends/abstract.html#client.version_control.backends.abstract.VersionControl.update_change_list_description","title":"<code>update_change_list_description(comment, new_comment)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Update the current change list's description to the given one.</p> <p>If the change list is not found it should raise: <code>ChangeListNotFoundError</code>.</p> <p>The implementation should also set <code>self.change_list_description = new_comment</code></p> Source code in <code>client/version_control/backends/abstract.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef update_change_list_description(comment, new_comment):\n    # type: (str, str) -&gt; bool\n    \"\"\"\n    Update the current change list's description to the given one.\n\n    If the change list is not found it should raise: `ChangeListNotFoundError`.\n\n    The implementation should also set `self.change_list_description = new_comment`\n    \"\"\"\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"autoapi/client/version_control/backends/undefined.html","title":"undefined","text":""},{"location":"autoapi/client/version_control/backends/perforce/index.html","title":"perforce","text":"<p>Backend for perforce access in OpenPype</p>"},{"location":"autoapi/client/version_control/backends/perforce/backend.html","title":"backend","text":""},{"location":"autoapi/client/version_control/backends/perforce/convert_to_py2_annotations.html","title":"convert_to_py2_annotations","text":""},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html","title":"rest_routes","text":""},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.AddEndpoint","title":"<code>AddEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of dict with project info (id, name).</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class AddEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Returns list of dict with project info (id, name).\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"AddEndpoint called\")\n        content = await request.json()\n\n        result = VersionControlPerforce.add(content[\"path\"],\n                                            content[\"comment\"])\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.CheckoutEndpoint","title":"<code>CheckoutEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of dict with project info (id, name).</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class CheckoutEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Returns list of dict with project info (id, name).\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"CheckoutEndpoint called\")\n\n        content = await request.json()\n\n        result = VersionControlPerforce.checkout(content[\"path\"],\n                                                 content[\"comment\"])\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.ExistsOnServer","title":"<code>ExistsOnServer</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns information about file on 'path'.</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class ExistsOnServer(PerforceRestApiEndpoint):\n    \"\"\"Returns information about file on 'path'.\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"exists_on_server called\")\n        content = await request.json()\n\n        result = VersionControlPerforce.exists_on_server(content[\"path\"])\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.GetChanges","title":"<code>GetChanges</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of submitted changes.</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class GetChanges(PerforceRestApiEndpoint):\n    \"\"\"Returns list of submitted changes.\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"GetChanges called\")\n        content = await request.json()\n\n        result = VersionControlPerforce.get_changes()\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.GetLastChangelist","title":"<code>GetLastChangelist</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of dict with project info (id, name).</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class GetLastChangelist(PerforceRestApiEndpoint):\n    \"\"\"Returns list of dict with project info (id, name).\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"GetLatestChangelist called\")\n        content = await request.json()\n\n        result = VersionControlPerforce.get_last_change_list()\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.GetServerVersionEndpoint","title":"<code>GetServerVersionEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of dict with project info (id, name).</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class GetServerVersionEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Returns list of dict with project info (id, name).\"\"\"\n    async def get(self) -&gt; Response:\n        result = VersionControlPerforce.get_server_version()\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.GetStreamEndpoint","title":"<code>GetStreamEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns stream attached to workspace.</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class GetStreamEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Returns stream attached to workspace.\"\"\"\n    async def post(self, request) -&gt; Response:\n        content = await request.json()\n\n        result = VersionControlPerforce.get_stream(content[\"workspace_name\"])\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.GetWorkspaceDirEndpoint","title":"<code>GetWorkspaceDirEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns stream attached to workspace.</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class GetWorkspaceDirEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Returns stream attached to workspace.\"\"\"\n    async def post(self, request) -&gt; Response:\n        content = await request.json()\n\n        result = VersionControlPerforce.get_workspace_dir(\n            content[\"workspace_name\"]\n        )\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.IsCheckoutedEndpoint","title":"<code>IsCheckoutedEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Checks if file is checkouted by sameone.</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class IsCheckoutedEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Checks if file is checkouted by sameone.\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"CheckoutEndpoint called\")\n\n        content = await request.json()\n\n        result = VersionControlPerforce.is_checkedout(content[\"path\"])\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.IsPathInAnyWorkspace","title":"<code>IsPathInAnyWorkspace</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of workspaces.</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class IsPathInAnyWorkspace(PerforceRestApiEndpoint):\n    \"\"\"Returns list of workspaces.\"\"\"\n    async def post(self, request) -&gt; Response:\n        content = await request.json()\n        result = api._is_path_under_any_root(content[\"path\"])\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.LoginEndpoint","title":"<code>LoginEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of workspaces.</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class LoginEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Returns list of workspaces.\"\"\"\n    async def post(self, request) -&gt; Response:\n        content = await request.json()\n        result = api.login(\n            content[\"host\"],\n            content[\"port\"],\n            content[\"username\"],\n            content[\"password\"],\n            content[\"workspace_name\"]\n        )\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.SubmitChangelist","title":"<code>SubmitChangelist</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of dict with project info (id, name).</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class SubmitChangelist(PerforceRestApiEndpoint):\n    \"\"\"Returns list of dict with project info (id, name).\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"SubmitChangelist called\")\n        content = await request.json()\n\n        result = VersionControlPerforce.submit_change_list(content[\"comment\"])\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.SyncLatestEndpoint","title":"<code>SyncLatestEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of dict with project info (id, name).</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class SyncLatestEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Returns list of dict with project info (id, name).\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"SyncLatestEndpoint called\")\n        content = await request.json()\n\n        result = VersionControlPerforce.sync_latest_version(content[\"path\"])\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/rest_routes.html#client.version_control.backends.perforce.rest_routes.SyncVersionEndpoint","title":"<code>SyncVersionEndpoint</code>","text":"<p>               Bases: <code>PerforceRestApiEndpoint</code></p> <p>Returns list of dict with project info (id, name).</p> Source code in <code>client/version_control/backends/perforce/rest_routes.py</code> <pre><code>class SyncVersionEndpoint(PerforceRestApiEndpoint):\n    \"\"\"Returns list of dict with project info (id, name).\"\"\"\n    async def post(self, request) -&gt; Response:\n        log.debug(\"SyncVersionEndpoint called\")\n        content = await request.json()\n\n        log.debug(f\"Syncing '{content['path']}' to {content['version']}\")\n        result = VersionControlPerforce.sync_to_version(content[\"path\"],\n                                                        content[\"version\"])\n        log.debug(\"Synced\")\n        return Response(\n            status=200,\n            body=self.encode(result),\n            content_type=\"application/json\"\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html","title":"api","text":"<p>An easier, more pythonic inteface for working with P4, built on P4Python.     Objects, methods and functions in this module handle connection     and errors automatically, managing the verbose approach required     in P4Python.</p>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.P4ConnectionManager","title":"<code>P4ConnectionManager</code>","text":"<p>This class is the core of this module.</p> <p>It manages the connection and error handling when sending commands to p4 via P4Python.</p> <p>It does this by providing a number of convenience mechanisms to reduce boiler plate code. The main mechanism is the handling of methods which require a p4 connection. Any attribute that both has <code>_connect_</code> as a prefix and is a method, will lazily wrap said method with <code>__run_connect__</code> and remove the <code>_connect_</code> prefix.</p> <p>For example: <code>_connect_sync</code> will be accessed with <code>sync</code>.</p> <p>This offers multiple benefits:</p> <ul> <li>core methods are marked as private.</li> <li>wrapping of methods is handled lazily, thus is performant.</li> <li>reduced verbosity of calling core method names.</li> </ul> <p>The <code>__run_connect__</code> wrapper works in conjunction with the <code>__connect__</code> context manager to automatically manage the p4.connect and p4.disconnect functionality. This is especially useful for nested <code>_connect_</code> method calls, as P4Python throws an exception if <code>p4.connect()</code> is called when an connection is already active.</p>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.P4ConnectionManager--any-method-that-requires-a-connection-to-p4","title":"*** Any method that requires a connection to p4,","text":""},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.P4ConnectionManager--must-be-declared-with-the-prefix-_connect_","title":"must be declared with the prefix: <code>_connect_</code> ***","text":"<p>The <code>__run_connect__</code> wrapper will also handle workspaces by attempting to run the given function in each workspace, returning as soon as the function runs successfully. The first workspace used will initially be the current workspace as defined by <code>p4.client</code>, and then it will be updated to the last workspace that a function was successfully run on. This should mean in most cases the function will only need to run the first time as most users pcs should be setup to have <code>p4.client</code> be their standard workspace, BUT if it fails, then the function will be run on all the other workspaces until it either succeeds or there are no workspaces left.</p> Source code in <code>client/version_control/backends/perforce/api/__init__.py</code> <pre><code>class P4ConnectionManager:\n    \"\"\"\n    This class is the core of this module.\n\n    It manages the connection and error handling\n    when sending commands to p4 via P4Python.\n\n    It does this by providing a number of convenience\n    mechanisms to reduce boiler plate code.\n    The main mechanism is the handling of methods\n    which require a p4 connection.\n    Any attribute that both has `_connect_` as a prefix\n    and is a method, will lazily wrap said method with\n    `__run_connect__` and remove the `_connect_` prefix.\n\n    For example: `_connect_sync` will be accessed with `sync`.\n\n    This offers multiple benefits:\n\n    - core methods are marked as private.\n    - wrapping of methods is handled lazily, thus is performant.\n    - reduced verbosity of calling core method names.\n\n    The `__run_connect__` wrapper works in conjunction with the\n    `__connect__` context manager to automatically manage the\n    p4.connect and p4.disconnect functionality.\n    This is especially useful for nested `_connect_`\n    method calls, as P4Python throws an exception if\n    `p4.connect()` is called when an connection is already\n    active.\n\n    # *** Any method that requires a connection to p4,\n    # must be declared with the prefix: `_connect_` ***\n\n    The `__run_connect__` wrapper will also handle workspaces by\n    attempting to run the given function in each workspace, returning\n    as soon as the function runs successfully.\n    The first workspace used will initially be the current workspace\n    as defined by `p4.client`, and then it will be updated to\n    the last workspace that a function was successfully run on.\n    This should mean in most cases the function will only need to\n    run the first time as most users pcs should be setup to have\n    `p4.client` be their standard workspace, BUT if it fails, then\n    the function will be run on all the other workspaces until it\n    either succeeds or there are no workspaces left.\n    \"\"\"\n\n    # Magic Methods:\n    def __init__(\n        self,\n        use_progress_hander: bool = False,\n        started_fn: Callable[[str, int], None] | None = None,\n        total_set_fn: Callable[[int], None] | None = None,\n        updated_fn: Callable[[int], None] | None = None,\n        completed_fn: Callable[[str, int], None] | None = None\n    ):\n\n        super().__init__()\n\n        self._p4 = None\n        self._connection_depth: int = 0\n        self._host_name: str = \"\"\n\n        self._is_offline = False\n        self._retry_p4_connection = False\n        self._offline_manager = None\n\n        self._break_run_loop: bool = False\n        self._run_successfully: bool = False\n        self.result: Any = None\n\n        self._attribute_errors: set[str] = set()\n        self._path_existence_errors: set[str] = set()\n        self.__workspace_cache__: list[str] = []\n        self.__clients_cache__: dict[str, dict[str, Any]] | None = None\n        self._workspace_errors: set[str] = set()\n\n        self._signaller = P4ConnectionManagerSignaller()\n\n        if not use_progress_hander:\n            return\n\n        self._progress_handler = P4ProgressHandler(\n            started_fn=started_fn,\n            total_set_fn=total_set_fn,\n            updated_fn=updated_fn,\n            completed_fn=completed_fn,\n        )\n        self.p4.progress = self._progress_handler\n\n    def __getattribute__(self, attribute_name) -&gt; Any:\n        \"\"\"\n        This is a custom handler for attribute access.\n\n        It allows methods that need wrapping with\n        `__run_connect__` to be wrapped when first called.\n        The alternative was for `__run_connect__` to exist\n        outside of P4ConnectionManager, which seemed janky.\n\n        A method with the prefix `_connect_` will be wrapped\n        with `__run_connect__` when first called and then assigned\n        back to the instance without the `_connect_` prefix.\n        This provides lazy creation and exposure of core methods.\n        For example:\n        This will expose the wrapped version of: `_connect_checkout`,\n        saving it as an attribute on the `P4ConnectionManager`\n        instance, to provide a quicker look up if accessed again:\n\n        ```\n        cm = P4ConnectionManager()\n        cm.checkout\n        ```\n\n        It is recommended to use the full method name when\n        calling from within the object (include `_connect_` prefix).\n        This avoids unneccesary connection checks, providing a slight\n        performance boost. I.E:\n        `self._connect_checkout` rather than `self.checkout`\n        \"\"\"\n        try:\n            attribute = object.__getattribute__(self, attribute_name)\n            return attribute\n\n        except AttributeError:\n            attribute_name = f\"_connect_{attribute_name}\"\n            try:\n                attribute = object.__getattribute__(self, attribute_name)\n                if isinstance(attribute, MethodType):\n                    __run_connect__ = object.__getattribute__(self, \"__run_connect__\")\n                    attribute = __run_connect__(attribute)\n                    object.__setattr__(self, attribute_name.replace(\"_connect_\", \"\"), attribute)\n\n                return attribute\n\n            except AttributeError:\n                _attribute_name = attribute_name.replace(\"_connect_\", \"\")\n                class_name = object.__getattribute__(self, \"__class__\").__name__\n                raise AttributeError(f\"{class_name} has no attribute: {_attribute_name}\")\n\n    # Properties:\n    @property\n    def p4(self) -&gt; P4.P4:\n        if self._p4 is None:\n            self._p4 = P4.P4()\n        return self._p4\n\n    @property\n    def host_name(self) -&gt; str:\n        if not self._host_name:\n            self._host_name = socket.gethostname()\n        return self._host_name\n\n    @property\n    def exceptions(self):\n        return p4_errors.P4Exceptions\n\n    @property\n    def is_offline(self):\n        return self._is_offline\n\n    @property\n    def offline_manager(self):\n        if self._offline_manager is None:\n            pass\n            # self._offline_manager = p4_offline.P4ConnectionManager()\n        return self._offline_manager\n\n    @property\n    def _clients_cache(self) -&gt; dict[str, dict[str, Any]]:\n        if self.__clients_cache__ is None:\n            host_name = self.host_name.lower()\n            self.__clients_cache__ = {\n                client[\"client\"]: client\n                for client in self.p4.run_clients(\"--me\")\n                if client[\"Host\"].lower() == host_name\n            }\n\n        return self.__clients_cache__\n\n    @property\n    def _workspace_cache(self):\n        if not self.__workspace_cache__:\n            self.__workspace_cache__ = self._connect_get_workspaces()\n\n        return self.__workspace_cache__\n\n    # Protected Methods:\n    @contextmanager\n    def __connect__(self) -&gt; Generator[P4.P4 | None, None, None]:\n        \"\"\"\n        Context manager that connects to if not already connected p4,\n        yielding the instance of p4 and closing the connection when done.\n        \"\"\"\n\n        if self._is_offline:\n            if not self._retry_p4_connection:\n                yield\n                return\n\n        if not self.p4.connected():\n            try:\n                self.p4.connect()\n                if self._is_offline:\n                    self._signaller.connected.emit()\n                    self._is_offline = False\n            except Exception as error:\n                if not self._is_p4_exception(error):\n                    raise\n\n                if \"[P4.connect()] Connect to server failed; check $P4PORT\" not in str(error):\n                    raise\n\n                self._is_offline = True\n                self._signaller.disconnected.emit()\n                self._start_retry_p4_connection_timer()\n                yield\n                return\n\n        self._connection_depth += 1\n        yield self.p4\n        self._connection_depth -= 1\n        if self._connection_depth == 0:\n            self.__clients_cache__ = None\n            self._process_errors()\n            self._process_warnings()\n            self.p4.disconnect()\n            self._clear_errors()\n\n    def __run_connect__(self, function):\n        # type: (Callable[..., Any]) -&gt; Callable[..., Any]\n        \"\"\"\n        Decorator that connects to p4 before running a function.\n\n        This is syntactic sugar to try and reduce indentation\n        in a function body.\n        Removing the need to use p4.connect in every function body:\n\n        ```\n        def function(self):\n            with p4.connect():\n                pass\n        ```\n\n        The intention is for this to work with P4ConnectionManager,\n        it will not work with standard functions.\n        \"\"\"\n\n        @functools.wraps(function)\n        def _connect(*args, **kwargs):\n            # type: (Any, Any) -&gt; Any\n            workspace_override = None\n            args_info = self._get_path_arg_info(function, args) if args else (None, False)\n            paths, compile_result = args_info\n            paths, args, kwargs, workspace_override = self._split_args(paths, args, kwargs)\n\n            with self.__connect__():\n                if self._is_offline:\n                    self.__run_function_offline__(\n                        function, paths, compile_result, args, kwargs\n                    )\n                else:\n                    self._update_workspace_cache(workspace_override or self.p4.client)\n                    for workspace in self._workspace_cache:\n                        with self.workspace_as(workspace):\n                            self.__run_function__(\n                                function, paths, workspace, compile_result, args, kwargs\n                            )\n                            if self._break_run_loop:\n                                break\n\n            if compile_result:\n                return self.result\n\n            _result = self.result\n            if not _result:\n                return _result\n\n            if isinstance(_result, dict):\n                _result = tuple(_result.values())\n\n            if isinstance(_result, (list, tuple)) and len(_result) == 1:\n                return _result[0]\n\n            return _result\n\n        return _connect\n\n    def __run_function__(self, function, paths, workspace, compile_result, args, kwargs):\n        # type: (Callable[..., Any], tuple[str, ...] | None, str, bool, tuple[Any], dict[str, Any]) -&gt; None\n        self.result = None\n        self._break_run_loop = False\n        self._run_successfully = False\n        try:\n            if paths and not self._are_paths_valid(paths, workspace):\n                return\n\n            is_get_stat = function == self._connect_get_stat\n            result = function(*args, **kwargs)  # type: Any\n            if is_get_stat:\n                result = (result, ) if paths and len(paths) == 1 and paths[0].endswith(\"...\") else result\n            self.result = self._compile_result(compile_result, paths, result)\n            self._run_successfully = True\n            self._break_run_loop = True\n            self._update_workspace_cache(workspace)\n            return\n\n        except p4_errors.P4PathDoesNotExistError as error:\n            self._path_existence_errors.add(str(error))\n            self._break_run_loop = True\n            return\n\n        except AttributeError as error:\n            if \"has no attribute\" in str(error):\n                raise\n\n            raise AttributeError(\"P4.P4 has no attribute: '{0}' \".format(error))\n\n        except Exception as error:\n            if not self._is_p4_exception(error):\n                raise\n\n            # @sharkmob-shea.richardson:\n            # As there are self.p4.warnings we can assume the\n            # function ran correclty but it has triggered a warning.\n            # This normally indicates that the correct workspace\n            # has been used but there is an issue with the operation\n            # so let's break out of the loop:\n            if self.p4.warnings:\n                self._run_successfully = True\n                self._break_run_loop = True\n                return\n            print(str(error))\n\n        return\n\n    def __run_function_offline__(self, function, paths, compile_result, args, kwargs):\n        # type: (Callable[..., Any], tuple[str, ...] | None, bool, tuple[Any], dict[str, Any]) -&gt; None\n        self.result = None\n        result = self.offline_manager.run_function(function, args, kwargs)\n        self.result = self._compile_result(compile_result, paths, result)\n\n    # Private Methods:\n    @staticmethod\n    def _get_valid_path_objects(_paths: P4PathType) -&gt; list[pathlib.Path]:\n        def _is_valid_path(_path: Union[str, pathlib.Path]) -&gt; bool:\n            if isinstance(_path, str):\n                _path = pathlib.Path(_path).anchor.lower()\n\n            _path_anchor_lower = _path.anchor.lower()\n            if (\n                not _path_anchor_lower[1:].startswith(\":\\\\\") and\n                not _path_anchor_lower.startswith(\"\\\\\\\\\")\n            ):\n                print(f\"Path is invalid: {_path}\")\n                return False\n\n            return True\n\n        path_objects = (\n            (pathlib.Path(_path) for _path in [_paths])\n            if isinstance(_paths, (str, pathlib.Path))\n            else (pathlib.Path(_path) for _path in _paths)\n        )\n\n        valid_paths = [path for path in path_objects if _is_valid_path(path)]\n        return valid_paths\n\n    @staticmethod\n    def _get_correct_p4_paths(\n        _paths: list[pathlib.Path],\n    ) -&gt; tuple[str]:\n        \"\"\"\n        Test if the path exists test if it is a file.\n            If the path doesn't exist and has an extension, then assume it is a file.\n            This is to try and figure out if the path is a folder and append \"/...\" if so\n        \"\"\"\n\n        out_paths: list[str] = []\n        for _path in _paths:\n            # Already declared as a directory:\n            _path_str = str(_path)\n            if _path_str.endswith(\"\\\\...\"):\n                out_paths.append(_path_str)\n                continue\n\n            # A depot path:\n            if _path_str.startswith(\"\\\\\\\\\"):\n                if not _path.suffix:\n                    _path_str = f\"{_path_str}\\\\...\"\n\n                _path_str = _path_str.replace(\"\\\\\", \"/\")\n                out_paths.append(_path_str)\n                continue\n\n            is_file = True if _path.exists() and _path.is_file() else _path.suffix\n            out_paths.append(_path_str if is_file else f\"{_path}\\\\...\")\n\n        return tuple(out_paths)\n\n    @staticmethod\n    def _is_file_checked_out_by_current_user(data: dict[str, Any]) -&gt; bool:\n        if \"action\" in data and data[\"action\"] == \"add\":\n            return True\n        if \"action\" in data and data[\"action\"] == \"edit\":\n            return True\n\n        return False\n\n    @staticmethod\n    def _compile_result(compile_result, paths, result):\n        # type: (bool, tuple[str] | None, Any | None) -&gt; Any\n        if compile_result and paths and isinstance(result, col_abc.Iterable):\n            result = {path.replace(\"\\\\...\", \"\"): data for path, data in zip(paths, result)}\n\n        return result\n\n    def _get_clean_p4_paths(self, paths: Iterable[str]):\n        valid_paths = self._get_valid_path_objects(paths)\n        return self._get_correct_p4_paths(valid_paths)\n\n    def _split_args(self, paths, args, kwargs):\n        # type: (tuple[str, ...] | None, tuple[Any, ...], dict[str, Any]) -&gt; tuple[tuple[str,...] | None, tuple[Any, ...], dict[str, Any], str | None]  # noqa\n        if paths:\n            valid_paths = self._get_valid_path_objects(paths)\n            paths = self._get_correct_p4_paths(valid_paths)\n            _args = list(args[1:])\n            _args.insert(0, paths)\n            args = tuple(_args)\n\n        workspace = None\n        if \"workspace_override\" in kwargs:\n            workspace = kwargs.pop(\"workspace_override\")\n            assert workspace is None or isinstance(workspace, str), (\n                \"workspace_override must be a string - got: {0} of type: {1}\".format(\n                    workspace, type(workspace)\n                )\n            )\n\n        return paths, args, kwargs, workspace\n\n    def _are_paths_valid(self, paths, workspace):\n        # type: (tuple[Any, ...], str) -&gt; bool\n        paths = make_tuple_if_not(paths)\n        if self._are_paths_under_root(workspace, paths):\n            return True\n\n        for path in paths:\n            self._workspace_errors.add(str(path))\n\n        return False\n\n    @lru_cache(maxsize=64)\n    def _get_workspace_roots(self, workspace: str) -&gt; tuple[str, str]:\n        \"\"\"Get the roots of the given workspace\"\"\"\n\n        if workspace not in self._clients_cache:\n            # @sharkmob-shea.richardson:\n            # Raise a P4Exception. If within the connect loop, will continue\n            # to the next workspace. If in a standalone function will raise a\n            # valid error. This handles the bug where client name is provided\n            # instead of a valid workspace name.\n            # This is a workaround rather than a fix as it is really hard to debug:\n            raise P4.P4Exception(f\"Invalid workspace name provided: '{workspace}'\")\n\n        client = self._clients_cache[workspace]\n        assert \"Root\" in client, (\n            f\"'Root' not found for workspace: '{workspace}'' - it is likely a dead!:\\n{client}\"\n        )\n        client_root = client[\"Root\"]\n        server_info = self._connect_get_path_info([f\"{client_root}\\\\...\"])[0]\n        server_root = server_info[\"depotFile\"].rstrip(\"...\")\n        return (\n            str(pathlib.Path(client_root)).lower(),\n            str(pathlib.Path(server_root)).lower()\n        )\n\n    @lru_cache(maxsize=64)\n    def _is_path_under_root(\n        self, path: Union[str, pathlib.Path], client_root: str, server_root: str\n    ) -&gt; bool:\n        path = str(path).lower()\n        if path.startswith(server_root):\n            return True\n\n        elif path.startswith(client_root):\n            return True\n\n        return False\n\n    # @lru_cache(maxsize=64)\n    def _are_paths_under_root(self, workspace: str, paths: tuple[str | pathlib.Path]):\n        client_root, server_root = self._get_workspace_roots(workspace)\n        for path in paths:\n            if self._is_path_under_root(path, client_root, server_root):\n                continue\n\n            return False\n\n        return True\n\n    @lru_cache(maxsize=64)\n    def _is_path_under_any_root(self, path: Union[str, pathlib.Path]):\n        for workspace in self._workspace_cache:\n            with self.workspace_as(workspace):\n                client_root, server_root = self._get_workspace_roots(workspace)\n                if self._is_path_under_root(path, client_root, server_root):\n                    return True\n        return False\n\n    @functools.lru_cache(maxsize=64)\n    def _args_has_path_or_workspace(self, signature):\n        # type: (inspect.Signature) -&gt; bool\n        \"\"\"\n        Test if the function to be wrapped has an argument\n        called `path`, returning True if so and False if not.\n        This will determine if path pre processing functions\n        should be run on the functions args or not.\n\n        This is cached to provide the best possible performance.\n        \"\"\"\n\n        if \"path\" not in signature.parameters and \"workspace\" not in signature.parameters:\n            return False\n\n        return True\n\n    @functools.lru_cache(maxsize=64)\n    def _get_path_index_from_args(self, signature):\n        # type: (inspect.Signature) -&gt; int | None\n        arg_names = tuple(signature.parameters)\n        path_index = None\n        if \"path\" in arg_names:\n            path_index = arg_names.index(\"path\")\n\n        return path_index\n\n    def _set_retry_p4_connection(self, value: bool):\n        self._retry_p4_connection = value\n\n    def _start_retry_p4_connection_timer(self, interval=5):\n        timer = threading.Timer(interval, self.test_connection)\n        timer.start()\n\n    def _update_workspace_cache(self, workspace):\n        \"\"\"\n        This puts the workspace that most recently worked at the\n        front of the `_workspace_cache` to try and reduce\n        the number of attempts on subsequent operations.\n        The idea is p4 operations work on batches of files\n        within the same workspace.\n        This won't always be the case, but it will make\n        large speed improvements when it is:\n        \"\"\"\n        if workspace not in self._workspace_cache:\n            print(\"Workspace is not valid: {} - cannot sort cache\".format(workspace))\n            return\n\n        index = self._workspace_cache.index(workspace)\n        if index:\n            self._workspace_cache.pop(index)\n            self._workspace_cache.insert(0, workspace)\n\n    def _get_path_arg_info(self, function, args):\n        # type: (Callable[..., Any], tuple[Any, ...]) -&gt; tuple[tuple[str] | None, bool]\n        signature = inspect.signature(function)\n        compile_result = False\n        if not self._args_has_path_or_workspace(signature):\n            return None, compile_result\n\n        path = None   # type: tuple[str] | None\n        path_index = self._get_path_index_from_args(signature)\n        if path_index is not None:\n            _path = args[path_index]\n            compile_result = isinstance(_path, (list, tuple))\n            _path = make_tuple_if_not(_path)\n            path = tuple(dict.fromkeys(_path).keys())\n\n        return path, compile_result\n\n    def _is_p4_exception(self, error):\n        # type: (Exception) -&gt; bool\n        \"\"\"\n        Query the exception type by `__name__` as it seems\n        that P4 can get confused if there are multiple P4\n        module paths available which results in P4Exception not\n        being caught as expected!\n        \"\"\"\n        return type(error).__name__ == \"P4Exception\"\n\n    def _clear_errors(self) -&gt; None:\n        self._attribute_errors.clear()\n        self._workspace_errors.clear()\n\n    def _process_errors(self) -&gt; None:\n        if self._run_successfully:\n            return\n\n        extra_path_existence_errors = []\n\n        def _process_workspace_errors(_extra_path_existence_errors):\n            if self.p4.errors and not self._attribute_errors:\n                if not self._workspace_errors:\n                    return False\n\n                error_text = \"The paths do not exist under a valid workspace root:\"\n                invalid_paths_found = False\n                for path in self._workspace_errors:\n                    if not self._is_path_under_any_root(path):\n                        error_text = f\"{error_text}\\n - {path}\"\n                        invalid_paths_found = True\n\n                if not invalid_paths_found:\n                    for path in self._workspace_errors:\n                        if not pathlib.Path(path).exists():\n                            _extra_path_existence_errors.append(path)\n\n                    if not _extra_path_existence_errors:\n                        return False\n\n                else:\n                    error_text = f\"{error_text}\\n\"\n                    sys.stderr.write(error_text)\n                    return True\n\n        def _process_path_existence_errors(_extra_path_existence_errors):\n            _path_existence_errors = self._path_existence_errors.copy()\n            _path_existence_errors.union(_extra_path_existence_errors)\n            if _path_existence_errors:\n                error_text = \"The following paths do not exist:\"\n                for path in _path_existence_errors:\n                    error_text = f\"{error_text}\\n - {path}\"\n\n                error_text = f\"{error_text}\\n\"\n                sys.stderr.write(error_text)\n\n        def _process_p4_attribute_errors():\n            if self._attribute_errors:\n                error_text = \"The following p4 attributes do not exist:\"\n                for error in self._attribute_errors:\n                    error_text = f\"{error_text}\\n - {error}\"\n\n                error_text = f\"{error_text}\\n\"\n                sys.stderr.write(error_text)\n\n        def _process_errors():\n            if self.p4.errors:\n                error_text = \"The following errors occured:\"\n                for error in self.p4.errors:\n                    error_text = f\"{error_text}\\n - {error}\"\n\n                error_text = f\"{error_text}\\n\"\n                sys.stderr.write(error_text)\n\n        if _process_workspace_errors(extra_path_existence_errors):\n            return\n\n        _process_path_existence_errors(extra_path_existence_errors)\n        _process_p4_attribute_errors()\n        _process_errors()\n\n    def _process_warnings(self) -&gt; None:\n        warnings = self.p4.warnings\n        if not warnings:\n            return\n\n        exclusive_check_outs = []\n        for warning in warnings:\n            if \" - can't edit exclusive file already opened\" in warning:\n                exclusive_check_outs.append(warning.split(\" -\")[0])\n\n        if exclusive_check_outs:\n            raise p4_errors.P4ExclusiveCheckoutError(exclusive_check_outs)\n\n        warning_text = \"The following warnings occurred:\"\n        warning_added = False\n        for warning in warnings:\n            warning = str(warning)\n            # if \" - no such file(s)\" in warning:\n            #     continue\n\n            warning_added = True\n            warning_text = f\"{warning_text}\\n {warning}\"\n\n        if warning_added:\n            warning_text = f\"{warning_text}\\n\"\n            sys.stdout.write(warning_text)\n\n        # warnings.clear()\n\n    if _typing:\n\n        @typing.overload\n        def _process_result(\n            self,\n            result,\n            keys,\n            actions,\n            none_keys=None,\n            none_actions=None,\n            true_pattern=...,\n            false_pattern=...,\n            set_none=False\n        ):\n            # type: (T_Result, T_Keys, T_Actions, T_NoneKeys, T_NoneActions, str, str, Literal[False]) -&gt; list[bool]  # noqa\n            ...\n\n        @typing.overload\n        def _process_result(\n            self,\n            result,\n            keys,\n            actions,\n            none_keys=None,\n            none_actions=None,\n            true_pattern=...,\n            false_pattern=...,\n            set_none=True\n        ):\n            # type: (T_Result, T_Keys, T_Actions, T_NoneKeys, T_NoneActions, str, str, Literal[True]) -&gt; list[bool | None]  # noqa\n            ...\n\n    def _process_result(\n        self,\n        result,\n        keys,\n        actions,\n        none_keys=None,\n        none_actions=None,\n        true_pattern=\"\",\n        false_pattern=\"\",\n        set_none=False\n    ):\n        # type: (T_Result, T_Keys, T_Actions, T_NoneKeys, T_NoneActions, str, str, Literal[True, False]) -&gt; list[bool | None] | list[bool]  # noqa\n        \"\"\"\n        Process the given result, matching expected key &amp; action pairs for\n        dictionary results or true or false patterns for string results\n        to determine if the result has been successful or not.\n        \"\"\"\n\n        keys = make_tuple_if_not(keys)\n        actions = make_tuple_if_not(actions)\n        none_keys = make_tuple_if_not(none_keys) if none_keys else tuple()\n        none_actions = make_tuple_if_not(none_actions) if none_actions else tuple()\n\n        def query_key(data, keys, actions, none_keys, none_actions, result, set_none=False):\n            # type: (dict[str, str], tuple[str], tuple[str], tuple[str], tuple[str], list[bool | None], bool) -&gt; None  # noqa\n            if set_none:\n                for key in none_keys:\n                    if key not in data:\n                        continue\n\n                    value = data[key]\n                    if value in none_actions:\n                        result.append(None)\n                        return\n\n            for key in keys:\n                if key not in data:\n                    continue\n\n                value = data[key]\n                if isinstance(value, list):\n                    value = value[0]\n\n                result.append(value in actions)\n                return\n\n            result.append(False)\n\n        results = []  # type: list[bool | None]\n        for data in result:\n            if not data and set_none:\n                results.append(None)\n                continue\n\n            if isinstance(data, dict):\n                query_key(data, keys, actions, none_keys, none_actions, results, set_none=set_none)\n                continue\n\n            if isinstance(data, str):\n                if true_pattern and true_pattern in data:\n                    results.append(True)\n                    continue\n\n                if false_pattern and false_pattern in data:\n                    results.append(False)\n                    continue\n\n                elif \"- empty, assuming\" in data:\n                    continue\n\n            results.append(False)\n            break\n\n        return results\n\n    def login(\n        self,\n        host: str,\n        port: int,\n        username: str,\n        password: str,\n        workspace_name: str\n    ):\n        \"\"\"Connects from values in Settings\n\n        Override P4CONFIG values.\n        \"\"\"\n        conn_manager = _get_connection_manager()\n        if conn_manager.p4.user != username:\n            conn_manager.p4.user = username\n            conn_manager.p4.password = password\n            conn_manager.p4.port = f\"{host}:{port}\"\n        conn_manager.p4.connect()\n        conn_manager.p4.run_login(password=password)\n        conn_manager.p4.client = workspace_name\n        conn_manager.__workspace_cache__ = self._connect_get_workspaces()\n\n    # Connect Methods:\n    def _connect_add(\n        self,\n        path: T_PthStrLst,\n        change_description: str | None = None,\n    ) -&gt; P4ReturnBoolType:\n        \"\"\"\n        Add the given file if it does not exists on the server already.\n        \"\"\"\n\n        for _path in path:\n            if not pathlib.Path(_path).exists():\n                raise p4_errors.P4PathDoesNotExistError(_path)\n\n        result = self.p4.run_add(path)\n        if change_description:\n\n            def _get_path_to_reopen(data):\n                # type: (str) -&gt; str | None\n                if \"already opened for edit\" in data:\n                    return data.split(\" - \")[0]\n\n                if \"currently opened for add\" in data:\n                    return data.split(\"#\")[0]\n\n            files_to_reopen = []  # type: list[str]\n            for _result in result:\n                if isinstance(_result, dict):\n                    continue\n\n                path_to_reopen = _get_path_to_reopen(_result)\n                if not path_to_reopen:\n                    continue\n\n                files_to_reopen.append(path_to_reopen)\n\n            if files_to_reopen:\n                self.p4.run_reopen([\"-c\", \"default\"], files_to_reopen)\n\n            self._connect_create_change_list(change_description, files=path)\n\n        return self._process_result(\n            result,\n            \"action\",\n            \"add\",\n            true_pattern=\"- currently opened for\"\n        )\n\n    def _connect_add_to_change_list(self, path: T_PthStrLst, description: str) -&gt; bool:\n        change_dict = self._connect_get_existing_change_list(description)\n        user_name = self._connect_get_user_name()\n        client = self.p4.client\n        changes: list[dict[str, Any]] = self.p4.run_changes(\n            [\"-u\", user_name, \"-c\", client, \"-s\", \"pending\"]\n        )\n        exists = self._connect_exists_on_server(path)\n        paths_to_add = [path[index] for index, exist in enumerate(exists) if not exist]\n        if paths_to_add:\n            self._connect_add(paths_to_add)\n\n        depot_paths = self._connect_get_server_path(path)\n\n        self._connect_checkout(path)\n        _depot_paths = set((path for path in depot_paths if path))\n        paths_to_reopen = []  # type: list[str]\n        changes = self.p4.run_describe([change[\"change\"] for change in changes])\n        for change in changes:\n            if \"depotFile\" not in change:\n                continue\n\n            if change[\"desc\"] == description:\n                continue\n\n            intersection = _depot_paths.intersection(\n                set(change[\"depotFile\"])\n            )\n            if not intersection:\n                continue\n\n            paths_to_reopen.extend(intersection)\n\n        if paths_to_reopen:\n            self.p4.run_reopen(\n                [\"-c\", \"default\"], paths_to_reopen\n            )\n\n        files = [info[\"depotFile\"] for info in self.p4.run_where(path)]\n        change_files = (\n            change_dict[\"Files\"]\n            if \"Files\" in change_dict\n            else []\n        )  # type: list[str]\n        change_files.extend(files)\n        change_files = list(set(change_files))\n        change_dict[\"Files\"] = change_files\n\n        _result = self.p4.save_change(change_dict)\n        result = self._process_result(\n            _result,\n            \"\",\n            \"\",\n            true_pattern=f\"adding {len(change_files)} file(s).\"\n        )\n        return result[0]\n\n    def _connect_checkout(\n        self,\n        path: T_PthStrLst,\n        change_description: str | None = None,\n    ) -&gt; bool | list[bool] | None:\n        \"\"\"\n        Checkout the given file(s).\n        \"\"\"\n\n        stat = self._connect_get_stat(path)\n        path = tuple((_stat[\"depotFile\"] for _stat in stat if _stat))\n\n        result = self._connect_is_latest(path)\n        paths_to_sync = [path for path, is_latest in zip(path, result) if is_latest is False]\n        if paths_to_sync:\n            self._connect_sync(paths_to_sync)\n\n        edit_result = self.p4.run_edit(path)\n        if change_description:\n            self._connect_create_change_list(change_description, files=path)\n\n        _result = self._process_result(\n            edit_result,\n            \"action\",\n            \"edit\",\n            true_pattern=\"- currently opened for\",\n            false_pattern=\"- can't edit (already opened for add)\",\n        )\n        if _result is None:\n            return None\n\n        return _result\n\n    def _connect_checked_out_by(\n        self, path: T_PthStrLst, other_users_only: bool = False, fstat_args: P4ArgsType = None\n    ) -&gt; list[list[tuple[str, str]] | None]:\n        stat = self._connect_get_stat(path, fstat_args or [])\n        current_user_name = self._connect_get_user_name() if not other_users_only else \"\"\n        checked_out_by_list: list[list[tuple[str, str]] | None] = []\n        for data in stat:\n            if not data:\n                checked_out_by_list.append(None)\n                continue\n\n            file_checked_out_by_list: list[str] = []\n            if (not other_users_only) and self._is_file_checked_out_by_current_user(data):\n                # @sharkmob-shea.richardson:\n                # Format this in the same way as if it were checked out by another user, so\n                # the output will be consistent:\n                file_checked_out_by_list.append(f\"{current_user_name}@{self.p4.client}\")\n\n            if \"otherOpen\" in data:\n                file_checked_out_by_list.extend(data[\"otherOpen\"])\n\n            if not file_checked_out_by_list:\n                checked_out_by_list.append(None)\n                continue\n\n            clean_file_checked_out_by_list = [\n                tuple(user_name.split(\"@\")) for user_name in file_checked_out_by_list\n            ]\n            checked_out_by_list.append(clean_file_checked_out_by_list)\n\n        return checked_out_by_list\n\n    def _connect_create_change_list(\n        self,\n        description: str,\n        files: T_PthStrLst | None = None,\n        files_to_reopen: T_PthStrLst | None = None\n    ) -&gt; list[bool]:\n        \"\"\"\n        Create a change list with the given description and optional files.\n        \"\"\"\n\n        try:\n            change_dict = self._connect_get_existing_change_list(description)\n        except P4.P4Exception:\n            change_dict = None\n\n        _files = []\n        if files:\n            files = (\n                [file for file in files if file not in files_to_reopen]\n                if files_to_reopen\n                else files\n            )\n            _files = [info[\"depotFile\"] for info in self.p4.run_where(files)]\n\n        if change_dict:\n            change_files = (\n                change_dict[\"Files\"]\n                if \"Files\" in change_dict\n                else []\n            )  # type: list[str]\n            change_files.extend(_files)\n            change_files = list(set(change_files))\n            change_dict[\"Files\"] = change_files\n\n        else:\n            change_dict = self.p4.fetch_change()\n            if not change_dict:\n                raise P4.P4Exception(\"Failed to create a new change list\")\n\n            change_dict[\"Files\"] = _files\n\n        if files_to_reopen:\n            self.p4.run_reopen(\n                [\"-c\", description], files_to_reopen\n            )\n\n        change_dict[\"Description\"] = description\n        save_change_result = self.p4.save_change(change_dict)\n        result = self._process_result(\n            save_change_result, \"\", \"\", true_pattern=\"created.\"\n        )\n\n        return result\n\n    def _connect_get_changes(self):\n        change_list = self._connect_run_command(\"changes\",\n                                                \"-s\", \"submitted\")\n        if not change_list:\n            return\n\n        # returns list as _process_result_ breaks dictionary\n        return change_list\n\n    def _connect_get_last_change_list(self):\n        change_list = self._connect_run_command(\"changes\",\n                                                \"-s\", \"submitted\",\n                                                \"-m\", 1)\n        if not change_list:\n            return\n\n        # returns list as _process_result_ breaks dictionary\n        return change_list\n\n    def _connect_get_change_list_number(self, description: str):\n        change_dict = self._connect_get_existing_change_list(description)\n        if not change_dict:\n            return\n\n        return change_dict[\"change\"]\n\n    def _connect_create_workspace(self, name: str, root: str, stream: str):\n        client = self.p4.fetch_client()\n        client[\"Client\"] = name\n        client[\"Root\"] = root\n        client[\"Stream\"] = stream\n        return self.p4.save_client(client)\n\n    def _connect_delete(\n        self,\n        path: T_PthStrLst,\n        change_description: str | None = None,\n    ) -&gt; list[bool]:\n        \"\"\"\n        Delete the given file if it exists on the server.\n        \"\"\"\n\n        if change_description:\n            change_number = self._connect_create_change_list(change_description)\n            result = self.p4.run_delete([\"-c\", change_number, path])\n        else:\n            result = self.p4.run_delete(path)\n\n        return self._process_result(result, \"action\", \"edit\")\n\n    def _connect_delete_change_list(self, description: str, force: bool = False) -&gt; list[bool]:\n        \"\"\"\n        Delete a change list based on it's description.\n        \"\"\"\n\n        change_list = self._connect_get_existing_change_list(description)\n        change_id = int(change_list[\"Change\"])\n        files = \"Files\" in change_list and change_list[\"Files\"]\n        if files and force:\n            self.p4.run_reopen([\"-c\", \"default\"], files)\n\n        change_result = self.p4.run_change([\"-d\", change_id])  # type: list[str]\n        result = self._process_result(\n            change_result,\n            \"\",\n            \"\",\n            true_pattern=f\"Change {change_id} deleted.\",\n            false_pattern=\"open file(s) associated with it and can't be deleted\"\n        )\n\n        return result\n\n    def _connect_exists_on_server(self, path: T_PthStrLst) -&gt; list[bool]:\n        # @sharkmob-shea.richardson:\n        # If self.path is a directory, limit the number of\n        # returned files from the fstat query, to avoid getting\n        # info on all sub files recursively. This is done by\n        # passing in the -m (max) argument and setting it as 1:\n        stat = self._connect_get_stat(path, [\"-m 1\"])\n        result = [True if \"depotFile\" in data else False for data in stat]\n        return result\n\n    def _connect_get_attribute(\n        self,\n        path: T_PthStrLst,\n        name: str,\n        default: Any = None,\n        raise_error:bool = False\n    ) -&gt; list[str | None]:\n        # -Oa flag: Output attributes set by p4 attribute.\n        result: list[dict[str, str]] = self.p4.run_fstat((\"-Oa\",), path)\n\n        def _get_attribute(data: dict[str, str], name: str):\n            for key, value in data.items():\n                if \"-\" in key and name in key:\n                    return value\n\n            if raise_error:\n                raise p4_errors.P4AttributeError(f\"'{name}' on: '{data['depotFile']}'\")\n\n            self._attribute_errors.add(f\"'{name}' on: '{data['depotFile']}'\")\n\n            return default\n\n        return [_get_attribute(_result, name) for _result in result]\n\n    def _connect_get_client_root(self):\n        result = self.p4.run_info()\n        return result[0][\"clientRoot\"]\n\n    def _connect_get_current_client_revision(self, path: T_PthStrLst) -&gt; list[int | None]:\n        \"\"\"\n        Get the current client revision numbers for the given path/paths.\n        \"\"\"\n\n        stat = self._connect_get_stat(path)\n        result = [int(data[\"haveRev\"]) if (\"haveRev\" in data) else 0 if data else None for data in stat]\n        return result\n\n    def _connect_get_version_info(self, path: T_PthStrLst) -&gt; list[tuple[int, int] | tuple[None, None]]:\n        return self._connect_get_current_revision_info(path)\n\n    def _connect_get_current_revision_info(self, path: T_PthStrLst) -&gt; list[tuple[int, int] | tuple[None, None]]:\n        \"\"\"\n        Get the current source and client revision numbers for the given path/paths.\n        \"\"\"\n\n        def _get_version_info(stat: dict[str, str]) -&gt; tuple[int, int] | tuple[None, None]:\n            if not stat:\n                return (None, None)\n\n            source_rev = stat[\"headRev\"] if \"headRev\" in stat else 0\n            local_rev = stat[\"haveRev\"] if \"haveRev\" in stat else 0\n            return int(source_rev), int(local_rev)\n\n        stat = self._connect_get_stat(path)\n\n        return [_get_version_info(data) for data in stat]\n\n    def _connect_get_current_server_revision(self, path: T_PthStrLst) -&gt; list[int | None]:\n        \"\"\"\n        Get the current source revision numbers for the given path/paths.\n        \"\"\"\n\n        stat = self._connect_get_stat(path)\n        result = [int(data[\"headRev\"]) if (\"headRev\" in data) else 0 if data else None for data in stat]\n        return result\n\n    def _connect_get_existing_change_list(self, description: str) -&gt; dict[str, Any]:\n        user_name = self._connect_get_user_name()\n        client = self.p4.client\n        changes: list[dict[str, Any]] = self.p4.run_changes(\n            [\"-u\", user_name, \"-c\", client, \"-s\", \"pending\"]\n        )\n\n        if not changes:\n            raise P4.P4Exception(\"No changelists found!\")\n\n        description = description.strip()\n        for change_data in self.p4.run_describe([change[\"change\"] for change in changes]):\n            if description != change_data[\"desc\"].strip():\n                continue\n\n            return self.p4.fetch_change(change_data[\"change\"])\n\n        raise P4.P4Exception(f'No changelist with description: \"{description}\" found!')\n\n    def _connect_get_files(\n        self, path: T_PthStrLst, extension: str | None = None, include_all: bool = False, query_sub_folders: bool = True\n    ) -&gt; list[tuple[pathlib.Path, ...]]:\n        extension = extension or \"\"\n        if isinstance(path, list):\n            path = [f\"{_path}{extension}\" for _path in path]\n\n        def _is_file_valid(_path, parent_path):\n            if query_sub_folders:\n                return True\n\n            return _path.parent == parent_path\n\n        result = []\n        for _path in path:\n            args = _path if include_all else [[\"-e\"], _path]\n            files = (pathlib.Path(data[\"depotFile\"]) for data in self.p4.run_files(args))\n            result.append(tuple((file for file in files if _is_file_valid(file, _path))))\n\n        return result\n\n    def _connect_get_files_in_folder_in_date_order(\n        self,\n        path: T_PthStrLst,\n        name_pattern: str | None = None,\n        extensions: Iterable[str] | None = None,\n        fstat_args: Iterable[str] | None = None,\n    ) -&gt; list[tuple[P4PathDateData]]:\n        result: list[tuple[P4PathDateData]] = []\n        fstat_args = list(fstat_args) if fstat_args else []\n        # -Sd: Sort by date.\n        # -Rc: Limit output to files mapped into the current workspace.\n        fstat_args.extend((\"-Sd\", \"-Rc\"))\n        for _path in path:\n            if not _path.endswith(\"...\"):\n                raise AttributeError(\n                    \"get_files_in_folder_in_date_order can only be run on folders!\"\n                )\n\n            stat = self._connect_get_stat((_path, ), args=fstat_args)\n            if name_pattern:\n                name_pattern = name_pattern.lower()\n\n            _extensions = None\n            if extensions is not None:\n                _extensions = set(\n                    (\n                        extension.lower()\n                        if extension.startswith(\".\")\n                        else \".{}\".format(extension).lower()\n                        for extension in extensions\n                    )\n                )\n\n            local_path = self._connect_get_local_path((_path, ))\n            if not local_path:\n                continue\n\n            _local_path = local_path[0]\n            parent_path_client = pathlib.Path(_local_path)\n            path_result: list[P4PathDateData] = []\n            for data in stat:\n                path_date_data = P4PathDateData()\n                if not data:\n                    path_date_data.set_data(None, None)\n\n                else:\n\n                    local_path = pathlib.Path(data[\"clientFile\"])\n                    if not local_path.parent == parent_path_client:\n                        continue\n\n                    if name_pattern and name_pattern not in local_path.stem.lower():\n                        continue\n\n                    if _extensions and local_path.suffix.lower() not in _extensions:\n                        continue\n\n                    if \"action\" in data and data[\"action\"] == \"add\":\n                        # @sharkmob-shea.richardson:\n                        # As the file has been marked for add,\n                        # all we have to go on is the last time\n                        # the file was modified locally:\n                        mod_time = local_path.stat().st_mtime\n                        mod_date = datetime.datetime.fromtimestamp(mod_time)\n                        path_date_data.set_data(local_path, mod_date)\n\n                    else:\n                        mod_time = int(data[\"headTime\"])\n                        mod_date = datetime.datetime.fromtimestamp(mod_time)\n                        path_date_data.set_data(local_path, mod_date)\n\n                path_result.append(path_date_data)\n\n            result.append(tuple(path_result))\n\n        return result\n\n    def _connect_get_info(self):\n        return self.p4.run_info()\n\n    def _connect_get_latest(self, path: T_PthStrLst) -&gt; list[bool | None]:\n        try:\n            sync_result = self.p4.run_sync(path)\n            result = self._process_result(sync_result, \"action\", (\"updated\", \"added\"), set_none=True)\n            return result\n        except Exception as error:\n            if not self._is_p4_exception(error):\n                raise\n\n            if not self.p4.warnings:\n                raise\n\n            # @sharkmob-shea.richardson:\n            # Sync has failed, potentially due to one or more of the files\n            # not existing on p4. Let's filter those files out of `path`\n            # and try sync again:\n            warnings = self.p4.warnings.copy()  # type: list[str]\n            result = [True] * len(path)  # type: list[bool | None]\n            latest_paths = tuple(\n                (\n                    (warning.replace(\" - file(s) up-to-date.\", \"\"), warnings.remove(warning))[0]\n                    for warning in reversed(warnings)\n                    if \"file(s) up-to-date.\" in warning\n                )\n            )\n\n            # @sharkmob-shea.richardson:\n            # All paths are already latest, so lets exit:\n            if len(latest_paths) == len(path):\n                return result\n\n            local_paths = tuple(\n                (\n                    (warning.replace(\" - no such file(s).\", \"\"), warnings.remove(warning))[0]\n                    for warning in reversed(warnings)\n                    if \"no such file(s).\" in warning\n                )\n            )\n            if local_paths:\n                for _path in local_paths:\n                    index = path.index(_path)\n                    result[index] = None\n\n            return result\n\n    def _connect_get_local_path(self, path: T_PthStrLst) -&gt; tuple[str]:\n        return tuple((data[\"path\"].rstrip(\"...\") for data in self.p4.run_where(path)))\n\n    def _connect_get_newest_file_in_folder(\n        self,\n        path: T_PthStrLst,\n        name_pattern: str | None = None,\n        extensions: Iterable[str] | None = None,\n    ):\n        paths = self._connect_get_files_in_folder_in_date_order(\n            path, name_pattern=name_pattern, extensions=extensions\n        )\n        if not paths:\n            return\n\n        if not paths[0]:\n            return\n\n        return paths[0][-1]\n\n    def _connect_get_path_locations(self, path: T_PthStrLst) -&gt; P4ReturnType:\n        return self._connect_get_path_info(path)\n\n    def _connect_get_path_info(self, path: T_PthStrLst) -&gt; P4ReturnType:\n        return self.p4.run_where(path)\n\n    def _connect_get_revision(\n        self,\n        path: T_PthStrLst,\n        revision: int | tuple[int],\n    ) -&gt; list[bool]:\n        if not isinstance(revision, (list, tuple)):\n            revision = tuple([revision] * len(path))\n\n        if not len(revision) == len(path):\n            raise AttributeError(f\"revision count ({len(revision)}) \"\n                                 f\"must match path count({len(path)})!\")\n\n        paths = [f\"{_path}@{_revision}\"\n                 for _path, _revision in zip(path, revision)]\n        sync_result = self.p4.run_sync(paths)\n        result = self._process_result(\n            sync_result,\n            \"action\",\n            (\"updated\", \"deleted\"),\n            true_pattern=\" - file(s) up-to-date.\"\n        )\n\n        return result\n\n    def _connect_get_revision_history(self, path: T_PthStrLst, include_all: bool = False):\n        args = [\"-t\"]\n        # if not include_all:\n        #     args.append(\"-s\")\n\n        # args_str = \" \".join(args)\n        # command = f\"{args_str} filelog\"\n        return self.p4.run_filelog(args, path)\n        # return self._connect_run_command(command, path)\n\n    def _connect_get_server_path(self, path: T_PthStrLst) -&gt; list[str | None]:\n        return [data[\"depotFile\"] if data else None for data in self.p4.run_where(path) if data]\n\n    def _connect_get_stat(\n        self, path: str | Sequence[str], args: P4ArgsType = None\n    ) -&gt; list[dict[str, str]]:\n\n        args = args or []\n        try:\n            # @sharkmob-shea.richardson:\n            # We query fstat of all the given paths.\n            # In most cases this will be a valid path or paths.\n            # If the path is invalid, ie doesn't exist, then this\n            # will throw an exception\n            stat = self.p4.run_fstat([args, path])\n        except Exception as error:\n            if not self._is_p4_exception(error):\n                raise\n\n            def _cull_no_such_file_warnings(index, warning, warnings_count):\n                # type: (int, str, int) -&gt; str\n                index = warnings_count - index\n                self.p4.warnings.pop(index)\n                return warning.replace(\" - no such file(s).\", \"\")\n\n            # @sharkmob-shea.richardson:\n            # fstat has failed, potentially due to one or more of the files\n            # not existing on p4. Let's filter those files out of `path`\n            # and try fstat again:\n            path = typing.cast(T_StrTuple, path)\n            warnings = tuple(reversed(self.p4.warnings))\n            warnings_count = len(warnings) - 1\n            excluded_paths = (\n                _cull_no_such_file_warnings(index, warning, warnings_count)\n                for index, warning in enumerate(warnings)\n                if \"no such file(s).\" in warning\n            )  # type: Generator[str, None, None]\n            exclude_data = {path.index(excluded_path): excluded_path for excluded_path in excluded_paths}\n            p4_path = tuple(filter(lambda i: i not in exclude_data.values(), path))\n            stat: list[dict[str, Any]] = self.p4.run_fstat([args, p4_path]) if p4_path else []\n\n            # @sharkmob-shea.richardson:\n            # we now need to add an empty dict into the indicies of\n            # the files that don't exist in perforce to allow\n            # the results to be mapped correctly when returned\n            # from __connect__\n            empty_dict = {}\n            for index in sorted((exclude_data.keys())):\n                stat.insert(index, empty_dict)\n\n        return stat\n\n    def _connect_get_streams(self) -&gt; tuple[str]:\n        streams = self.p4.run_streams()\n        return tuple((stream[\"Stream\"] for stream in streams))\n\n    def _connect_get_user_name(self) -&gt; str:\n        user_data = self.p4.run_user(\"-o\")[0]\n        return user_data[\"User\"] if user_data and \"User\" in user_data else \"\"\n\n    def _connect_get_workspaces(self, stream: str | None = None) -&gt; list[str]:\n        host_name = self.host_name.lower()\n        client_data = self.p4.run_clients(\"--me\")\n        if stream:\n            stream = stream.lower()\n            workspaces = (\n                data[\"client\"]\n                for data in client_data\n                if data[\"Host\"].lower() == host_name and data[\"Stream\"].lower() == stream\n            )\n\n        else:\n            workspaces = (data[\"client\"] for data in client_data if data[\"Host\"].lower() == host_name)\n\n        workspaces = list(dict.fromkeys(workspaces).keys())\n        return workspaces\n\n    def _connect_is_checked_out_by_user(\n        self, path: T_PthStrLst, user_name: tuple[str] | str | None = None\n    ) -&gt; list[bool]:\n        result: list[bool] = []\n        checked_out_by = self._connect_checked_out_by(path)\n        user_names = None if user_name is None else make_tuple_if_not(user_name)\n        user_names = set(user_names or (self._connect_get_user_name(),))\n        for _checked_out_by in checked_out_by:\n            if _checked_out_by is None:\n                result.append(False)\n                continue\n\n            user_found = False\n            checked_out_by_set = set((name for name, _ in _checked_out_by))\n            for user_name in user_names:\n                if user_name in checked_out_by_set:\n                    user_found = True\n                    break\n\n            if user_found:\n                result.append(True)\n                continue\n\n            result.append(False)\n\n        return result\n\n    def _connect_is_checked_out(self, path: T_PthStrLst) -&gt; list[bool | None]:\n        stat_result = self._connect_get_stat(path)\n        result = self._process_result(\n            stat_result,\n            (\"otherAction\", \"action\"),\n            (\"edit\", \"add\"),\n            none_keys=(\"headAction\", ),\n            none_actions=(\"delete\", ),\n            set_none=True\n        )\n\n        return result\n\n    def _connect_is_latest(self, path):\n        # type: (Sequence[str]) -&gt; tuple[bool | None]\n        result = dict.fromkeys(path, False)  # type: dict[str, bool | None]\n        files = []  # type: list[str]\n        folders = []  # type: list[str]\n        for _path in path:\n            if _path.endswith(\"...\"):\n                folders.append(_path)\n                continue\n            files.append(_path)\n\n        if folders:\n            def _is_folder_latest(folder):\n                # type: (str) -&gt; bool | None\n                # @sharkmob-shea.richardson\n                # We have to test each folder individually else P4\n                # condenses all the returned statistics into one.\n                # This makes it impossible to work out which folders\n                # need syncing and which do not.\n                try:\n                    sync_result = self.p4.run_sync((\"-N\"), folder)[0]\n                except Exception as error:\n                    if not self._is_p4_exception(error):\n                        raise\n\n                    return None\n\n                change_count_str = sync_result.split(\"=\")[1]  # type: str\n                change_count_str = change_count_str.split(\",\")[0]\n                change_counts = (bool(int(value)) for value in change_count_str.split(\"/\"))\n                return not any(change_counts)\n\n            for folder in folders:\n                result[folder] = _is_folder_latest(folder)\n\n        stat = self._connect_get_stat(files)\n        valid_states = {\"add\", \"move/add\", \"edit\"}\n        def _is_file_latest(data):\n            # type: (dict) -&gt; bool | None\n            if not data:\n                return\n            if \"action\" in data and data[\"action\"] in valid_states:\n                return True\n            if \"headRev\" not in data:\n                return False\n            if \"haveRev\" not in data:\n                return False\n\n            return data[\"headRev\"] == data[\"haveRev\"]\n\n        for file, data in zip(files, stat):\n            is_latest = _is_file_latest(data)\n            result[file] = is_latest\n\n        return tuple(result.values())\n\n    def _connect_is_stream_valid(self, stream: str) -&gt; bool:\n        streams = self._connect_get_streams()\n        return stream.lower() in set([stream.lower() for stream in streams])\n\n    def _connect_move(\n        self,\n        path: T_PthStrLst,\n        target_path: T_PthStrLst,\n        change_description: str | None = None,\n        get_latest: bool = True\n    ) -&gt; list[bool]:\n        target_path = make_tuple_if_not(target_path)  # type: ignore\n        clean_paths = self._get_clean_p4_paths(target_path)\n        if get_latest:\n            paths_to_sync = list(path).copy()\n            paths_to_sync.extend(\n                (\n                    path for path\n                    in clean_paths\n                    if pathlib.Path(path).exists()\n                )\n            )\n            if paths_to_sync:\n                sync_result = {}\n                try:\n                    sync_result = self._connect_get_latest(paths_to_sync)\n                except P4.P4Exception:\n                    pass\n\n                for result in paths_to_sync:\n                    if sync_result is False:\n                        raise P4.P4Exception(\"Files are not the latest versions!\")\n\n        path = typing.cast(T_StrTuple, path)\n        if len(path) != len(clean_paths):\n            raise ValueError(\"path length must equal target_path length\")\n\n        self._connect_checkout(path, change_description=change_description)\n        args = []\n        if change_description:\n            change_number = self._connect_get_change_list_number(change_description)\n            args.extend((\"-c\", change_number))\n\n        move_result = []\n        for source, target in zip(path, target_path):\n            _args = args.copy()\n            _args.extend((source, target))\n            result = self.p4.run_move(_args)\n            move_result.append(result[0])\n\n        result = self._process_result(\n            move_result,\n            \"action\",\n            \"move/add\",\n            true_pattern=\"can't move (already opened for move/delete)\"\n        )\n\n        return result\n\n    def _connect_revert(self, path: T_PthStrLst) -&gt; list[bool] | None:\n        revert_result: list[dict[str, Any]] = self.p4.run_revert(path)\n        _revert_result = (data for data in revert_result if data[\"clientFile\"] in path or data[\"depotFile\"] in path)\n        result = self._process_result(\n            _revert_result,\n            \"action\",\n            (\"abandoned\", \"reverted\", \"deleted\"),\n            true_pattern=\"- currently opened for\"\n        )\n        return result\n\n    def _connect_run_command(self, cmd: str, *args, **kwargs):\n        result = self.p4.run(cmd, *args, **kwargs)\n        return result\n\n    def _connect_set_attribute(self, path: T_PthStrLst, name: str, value: Any):\n        attrubute_result = self.p4.run_attribute((\"-n\", name, \"-v\", value), path)\n        result = self._process_result(attrubute_result, \"status\", \"set\")\n        return result\n\n    def _connect_submit_change_list(self, change_description: str) -&gt; int | None:\n        change_list_spec = self._connect_get_existing_change_list(change_description)\n        result = self.p4.run_submit(change_list_spec)\n        if not result:\n            return None\n\n        return int(result[0][\"change\"])\n\n    def _connect_sync(self, path):\n        \"\"\"\n        Synonym for get_latest\n        \"\"\"\n\n        return self._connect_get_latest(path)\n\n    def _connect_unsync(self, path: T_PthStrLst):\n        _path = [f\"{p}#none\" for p in path] if isinstance(path, (list, tuple)) else f\"{path}#none\"\n        sync_result = self.p4.run_sync(_path)\n        result = self._process_result(sync_result, \"action\", \"deleted\")\n        return result\n\n    def _connect_update_change_list_description(self, old_description: str, new_description: str):\n        change_list_spec = self._connect_get_existing_change_list(old_description)\n        if not change_list_spec:\n            raise P4.P4Exception(\"Changelist not found\")\n\n        change_list_spec[\"Description\"] = new_description\n        change_result = self.p4.save_change(change_list_spec)\n        result = self._process_result(\n            change_result, \"\", \"\", true_pattern=f\"Change {change_list_spec['Change']} updated.\"\n        )\n        return result\n\n    # Public Methods:\n    @contextmanager\n    def workspace_as(self, workspace: str) -&gt; Iterator[None]:\n        \"\"\"Context manager that connects to if not already connected p4,\n        yielding the instance of p4 and closing the connection when done.\n        \"\"\"\n\n        current_workspace = self.p4.client\n        try:\n            self.p4.client = workspace\n            yield\n\n        except:\n            raise\n\n        finally:\n            self.p4.client = current_workspace\n\n    def test_connection(self) -&gt; bool:\n        try:\n            with self.p4.connect():\n                if self._is_offline:\n                    self._signaller.connected.emit()\n                    self._is_offline = False\n\n                self._start_retry_p4_connection_timer(interval=60)\n                return True\n\n        except Exception as error:\n            if not self._is_p4_exception(error):\n                raise\n\n            if not self._is_offline:\n                self._is_offline = True\n                self._signaller.disconnected.emit()\n\n            self._start_retry_p4_connection_timer()\n            return False\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.P4ConnectionManager.__connect__","title":"<code>__connect__()</code>","text":"<p>Context manager that connects to if not already connected p4, yielding the instance of p4 and closing the connection when done.</p> Source code in <code>client/version_control/backends/perforce/api/__init__.py</code> <pre><code>@contextmanager\ndef __connect__(self) -&gt; Generator[P4.P4 | None, None, None]:\n    \"\"\"\n    Context manager that connects to if not already connected p4,\n    yielding the instance of p4 and closing the connection when done.\n    \"\"\"\n\n    if self._is_offline:\n        if not self._retry_p4_connection:\n            yield\n            return\n\n    if not self.p4.connected():\n        try:\n            self.p4.connect()\n            if self._is_offline:\n                self._signaller.connected.emit()\n                self._is_offline = False\n        except Exception as error:\n            if not self._is_p4_exception(error):\n                raise\n\n            if \"[P4.connect()] Connect to server failed; check $P4PORT\" not in str(error):\n                raise\n\n            self._is_offline = True\n            self._signaller.disconnected.emit()\n            self._start_retry_p4_connection_timer()\n            yield\n            return\n\n    self._connection_depth += 1\n    yield self.p4\n    self._connection_depth -= 1\n    if self._connection_depth == 0:\n        self.__clients_cache__ = None\n        self._process_errors()\n        self._process_warnings()\n        self.p4.disconnect()\n        self._clear_errors()\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.P4ConnectionManager.__getattribute__","title":"<code>__getattribute__(attribute_name)</code>","text":"<p>This is a custom handler for attribute access.</p> <p>It allows methods that need wrapping with <code>__run_connect__</code> to be wrapped when first called. The alternative was for <code>__run_connect__</code> to exist outside of P4ConnectionManager, which seemed janky.</p> <p>A method with the prefix <code>_connect_</code> will be wrapped with <code>__run_connect__</code> when first called and then assigned back to the instance without the <code>_connect_</code> prefix. This provides lazy creation and exposure of core methods. For example: This will expose the wrapped version of: <code>_connect_checkout</code>, saving it as an attribute on the <code>P4ConnectionManager</code> instance, to provide a quicker look up if accessed again:</p> <pre><code>cm = P4ConnectionManager()\ncm.checkout\n</code></pre> <p>It is recommended to use the full method name when calling from within the object (include <code>_connect_</code> prefix). This avoids unneccesary connection checks, providing a slight performance boost. I.E: <code>self._connect_checkout</code> rather than <code>self.checkout</code></p> Source code in <code>client/version_control/backends/perforce/api/__init__.py</code> <pre><code>def __getattribute__(self, attribute_name) -&gt; Any:\n    \"\"\"\n    This is a custom handler for attribute access.\n\n    It allows methods that need wrapping with\n    `__run_connect__` to be wrapped when first called.\n    The alternative was for `__run_connect__` to exist\n    outside of P4ConnectionManager, which seemed janky.\n\n    A method with the prefix `_connect_` will be wrapped\n    with `__run_connect__` when first called and then assigned\n    back to the instance without the `_connect_` prefix.\n    This provides lazy creation and exposure of core methods.\n    For example:\n    This will expose the wrapped version of: `_connect_checkout`,\n    saving it as an attribute on the `P4ConnectionManager`\n    instance, to provide a quicker look up if accessed again:\n\n    ```\n    cm = P4ConnectionManager()\n    cm.checkout\n    ```\n\n    It is recommended to use the full method name when\n    calling from within the object (include `_connect_` prefix).\n    This avoids unneccesary connection checks, providing a slight\n    performance boost. I.E:\n    `self._connect_checkout` rather than `self.checkout`\n    \"\"\"\n    try:\n        attribute = object.__getattribute__(self, attribute_name)\n        return attribute\n\n    except AttributeError:\n        attribute_name = f\"_connect_{attribute_name}\"\n        try:\n            attribute = object.__getattribute__(self, attribute_name)\n            if isinstance(attribute, MethodType):\n                __run_connect__ = object.__getattribute__(self, \"__run_connect__\")\n                attribute = __run_connect__(attribute)\n                object.__setattr__(self, attribute_name.replace(\"_connect_\", \"\"), attribute)\n\n            return attribute\n\n        except AttributeError:\n            _attribute_name = attribute_name.replace(\"_connect_\", \"\")\n            class_name = object.__getattribute__(self, \"__class__\").__name__\n            raise AttributeError(f\"{class_name} has no attribute: {_attribute_name}\")\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.P4ConnectionManager.__run_connect__","title":"<code>__run_connect__(function)</code>","text":"<p>Decorator that connects to p4 before running a function.</p> <p>This is syntactic sugar to try and reduce indentation in a function body. Removing the need to use p4.connect in every function body:</p> <pre><code>def function(self):\n    with p4.connect():\n        pass\n</code></pre> <p>The intention is for this to work with P4ConnectionManager, it will not work with standard functions.</p> Source code in <code>client/version_control/backends/perforce/api/__init__.py</code> <pre><code>def __run_connect__(self, function):\n    # type: (Callable[..., Any]) -&gt; Callable[..., Any]\n    \"\"\"\n    Decorator that connects to p4 before running a function.\n\n    This is syntactic sugar to try and reduce indentation\n    in a function body.\n    Removing the need to use p4.connect in every function body:\n\n    ```\n    def function(self):\n        with p4.connect():\n            pass\n    ```\n\n    The intention is for this to work with P4ConnectionManager,\n    it will not work with standard functions.\n    \"\"\"\n\n    @functools.wraps(function)\n    def _connect(*args, **kwargs):\n        # type: (Any, Any) -&gt; Any\n        workspace_override = None\n        args_info = self._get_path_arg_info(function, args) if args else (None, False)\n        paths, compile_result = args_info\n        paths, args, kwargs, workspace_override = self._split_args(paths, args, kwargs)\n\n        with self.__connect__():\n            if self._is_offline:\n                self.__run_function_offline__(\n                    function, paths, compile_result, args, kwargs\n                )\n            else:\n                self._update_workspace_cache(workspace_override or self.p4.client)\n                for workspace in self._workspace_cache:\n                    with self.workspace_as(workspace):\n                        self.__run_function__(\n                            function, paths, workspace, compile_result, args, kwargs\n                        )\n                        if self._break_run_loop:\n                            break\n\n        if compile_result:\n            return self.result\n\n        _result = self.result\n        if not _result:\n            return _result\n\n        if isinstance(_result, dict):\n            _result = tuple(_result.values())\n\n        if isinstance(_result, (list, tuple)) and len(_result) == 1:\n            return _result[0]\n\n        return _result\n\n    return _connect\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.P4ConnectionManager.login","title":"<code>login(host, port, username, password, workspace_name)</code>","text":"<p>Connects from values in Settings</p> <p>Override P4CONFIG values.</p> Source code in <code>client/version_control/backends/perforce/api/__init__.py</code> <pre><code>def login(\n    self,\n    host: str,\n    port: int,\n    username: str,\n    password: str,\n    workspace_name: str\n):\n    \"\"\"Connects from values in Settings\n\n    Override P4CONFIG values.\n    \"\"\"\n    conn_manager = _get_connection_manager()\n    if conn_manager.p4.user != username:\n        conn_manager.p4.user = username\n        conn_manager.p4.password = password\n        conn_manager.p4.port = f\"{host}:{port}\"\n    conn_manager.p4.connect()\n    conn_manager.p4.run_login(password=password)\n    conn_manager.p4.client = workspace_name\n    conn_manager.__workspace_cache__ = self._connect_get_workspaces()\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.P4ConnectionManager.workspace_as","title":"<code>workspace_as(workspace)</code>","text":"<p>Context manager that connects to if not already connected p4, yielding the instance of p4 and closing the connection when done.</p> Source code in <code>client/version_control/backends/perforce/api/__init__.py</code> <pre><code>@contextmanager\ndef workspace_as(self, workspace: str) -&gt; Iterator[None]:\n    \"\"\"Context manager that connects to if not already connected p4,\n    yielding the instance of p4 and closing the connection when done.\n    \"\"\"\n\n    current_workspace = self.p4.client\n    try:\n        self.p4.client = workspace\n        yield\n\n    except:\n        raise\n\n    finally:\n        self.p4.client = current_workspace\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/index.html#client.version_control.backends.perforce.api.__getattr__","title":"<code>__getattr__(attribute_name)</code>","text":"<p>Custom getattr for this module that will return the method of the module level P4ConnectionManager.</p> <pre><code>This achieves two things:\n    1. Allows a single P4ConnectionManager to be used for one off calls\n        in the main thread, without the need to init a new P4ConnectionManager\n        for each call.\n    2. Reduces the boilerplate required to expose the calls of the single\n        P4ConnectionManager, whilst still making the functionality\n        accessible at the module level.\n\nArgs:\n    attribute_name (str): The name of the module level attribute to access.\n\nReturns:\n    Any: The accessed attribute.\n</code></pre> Source code in <code>client/version_control/backends/perforce/api/__init__.py</code> <pre><code>def __getattr__(attribute_name: str) -&gt; Any:\n    \"\"\"\n    Custom __getattr__ for this module that will return\n    the method of the module level P4ConnectionManager.\n\n        This achieves two things:\n            1. Allows a single P4ConnectionManager to be used for one off calls\n                in the main thread, without the need to init a new P4ConnectionManager\n                for each call.\n            2. Reduces the boilerplate required to expose the calls of the single\n                P4ConnectionManager, whilst still making the functionality\n                accessible at the module level.\n\n        Args:\n            attribute_name (str): The name of the module level attribute to access.\n\n        Returns:\n            Any: The accessed attribute.\n    \"\"\"\n\n    connection_manager = _get_connection_manager()\n    if hasattr(connection_manager, attribute_name):\n        return getattr(connection_manager, attribute_name)\n\n    _globals = globals()\n    if attribute_name in _globals:\n        return getattr(_globals, attribute_name)\n\n    raise AttributeError(f\"{__name__} has no attribute: {attribute_name}!\")\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/p4_dcc.html","title":"p4_dcc","text":""},{"location":"autoapi/client/version_control/backends/perforce/api/p4_dcc.html#client.version_control.backends.perforce.api.p4_dcc.on_post_open","title":"<code>on_post_open(file_path, tool_name)</code>","text":"<p>Check if the given file exists on the server.</p> <p>This is called after a file has loaded. If the file is not on p4, add it automatically, prompt the user if they want to add it or ignore it all together, depending on the users p4 settings.</p> <pre><code>- `file_path`: The path to check.\n- `tool_name`: The name of the tool to run this operation for.\n    This allows the correct settings to be queried.\n</code></pre> Source code in <code>client/version_control/backends/perforce/api/p4_dcc.py</code> <pre><code>def on_post_open(file_path: _PathTypes, tool_name: str) -&gt; None:\n    \"\"\"\n    Check if the given file exists on the server.\n\n    This is called after a file has loaded.\n    If the file is not on p4, add it automatically, prompt the\n    user if they want to add it or ignore it all together,\n    depending on the users p4 settings.\n\n    Arguments:\n    ---------\n        - `file_path`: The path to check.\n        - `tool_name`: The name of the tool to run this operation for.\n            This allows the correct settings to be queried.\n    \"\"\"\n\n    file_path = pathlib.Path(file_path)\n    add_on_load = tool_settings.get_setting(tool_name, \"add_on_load\", default_setting_value=True)\n    if not add_on_load:\n        return\n\n    if api.is_offline:\n        if add_on_load:\n            sm_dialogs.show_message_box(\n                \"Perforce is offline, add command is being added to the offline cache!\"\n            )\n        file_path.p4.add()\n        return\n\n    exists_on_server = file_path.p4.exists_on_server\n    if exists_on_server:\n        return\n\n    add_on_load_behaviour = tool_settings.get_setting(\n        tool_name, \"add_on_load_behaviour\", default_setting_value=\"Prompt\"\n    )\n    file_path_short = f\"...{str(file_path).split('Art')[-1]}\"\n    prompt_post_save = add_on_load_behaviour == \"Prompt\"\n    add_file = True\n    if (not exists_on_server) and prompt_post_save:\n        add_file = sm_dialogs.show_query_box(\n            f\"Would you like to add this file to p4:\\n\\n{file_path_short}\"\n        )\n\n    if not add_file:\n        return\n\n    if file_path.p4.add():\n        print(f\"Added file:\\n - {file_path}\")\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/p4_dcc.html#client.version_control.backends.perforce.api.p4_dcc.on_post_save","title":"<code>on_post_save(file_path, tool_name)</code>","text":"<p>Check if the given path exists on perforce and adds it if not, offering the appropriate prompts to the user during the process.</p> <pre><code>- `file_path`: The path to check.\n- `tool_name`: The name of the tool to run this operation for.\n    This allows the correct settings to be queried.\n</code></pre> Source code in <code>client/version_control/backends/perforce/api/p4_dcc.py</code> <pre><code>def on_post_save(file_path: _PathTypes, tool_name: str) -&gt; None:\n    \"\"\"\n    Check if the given path exists on perforce and adds it if not,\n    offering the appropriate prompts to the user during the process.\n\n\n    Arguments:\n    ---------\n        - `file_path`: The path to check.\n        - `tool_name`: The name of the tool to run this operation for.\n            This allows the correct settings to be queried.\n\n    \"\"\"\n    file_path = pathlib.Path(file_path)\n    add_on_save = tool_settings.get_setting(tool_name, \"add_on_save\", default_setting_value=True)\n    if not add_on_save:\n        return\n\n    if api.is_offline and add_on_save:\n        sm_dialogs.show_message_box(\n            \"Peforce is offline, add command is being added to the offline cache!\"\n        )\n        file_path.p4.add()\n        return\n\n    exists_on_server = file_path.p4.exists_on_server\n    if exists_on_server:\n        return\n\n    add_on_save_behaviour = tool_settings.get_setting(\n        tool_name, \"add_on_save_behaviour\", default_setting_value=\"Automatically\"\n    )\n    prompt_post_save = add_on_save_behaviour == \"Prompt\"\n    add_file = True\n    file_path_short = f\"...{str(file_path).split('Art')[-1]}\"\n    if (not exists_on_server) and prompt_post_save:\n        add_file = sm_dialogs.show_query_box(\n            f\"Would you like to add this file to p4:\\n\\n{file_path_short}\"\n        )\n\n    if not add_file:\n        return\n\n    if file_path.p4.add():\n        print(f\"Added file:\\n - {file_path}\")\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/p4_dcc.html#client.version_control.backends.perforce.api.p4_dcc.on_pre_open","title":"<code>on_pre_open(file_path, tool_name)</code>","text":"<p>Check if the given file exists on the server and if it is latest, offering the appropriate prompts to the user during the process.</p> <pre><code>- `file_path`: The path to check.\n- `tool_name`: The name of the tool to run this operation for.\n    This allows the correct settings to be queried.\n</code></pre> <pre><code>`True` if the file is exists on the server and is latest, `False` if not.\n</code></pre> Source code in <code>client/version_control/backends/perforce/api/p4_dcc.py</code> <pre><code>def on_pre_open(file_path: _PathTypes, tool_name: str) -&gt; bool:\n    \"\"\"\n    Check if the given file exists on the server and if it is latest,\n    offering the appropriate prompts to the user during the process.\n\n    Arguments:\n    ---------\n        - `file_path`: The path to check.\n        - `tool_name`: The name of the tool to run this operation for.\n            This allows the correct settings to be queried.\n\n    Returns:\n    --------\n        `True` if the file is exists on the server and is latest, `False` if not.\n    \"\"\"\n\n    _file_path = pathlib.Path(file_path)\n    get_latest_on_load_behaviour = tool_settings.get_setting(\n        tool_name, \"get_latest_on_load_behaviour\", default_setting_value=\"Prompt\"\n    )\n    if api.is_offline:\n        if get_latest_on_load_behaviour == \"Prompt\":\n            sm_dialogs.show_message_box(\n                (\n                    \"Perforce is offline, cannot get latest if local file is out of sync!\\n\"\n                    \"!!! Work with caution !!!\"\n                )\n            )\n\n        return False\n\n    exists_on_server = _file_path.p4.exists_on_server\n    if not exists_on_server:\n        return False\n\n    file_path_short = f\"...{str(_file_path).split('Art')[-1]}\"\n    get_latest_on_load = tool_settings.get_setting(\n        tool_name, \"get_latest_on_load\", default_setting_value=True\n    )\n    warn_if_checked_out: bool = tool_settings.get_setting(\n        tool_name, \"load_warn_checked_out\", default_setting_value=True\n    )\n    if warn_if_checked_out:\n        _checked_out_by = _file_path.p4.checked_out_by\n        workspaces = set(api.get_workspaces())\n        checked_out_by = [\n            f\"'{user}' in workspace: '{workspace}'\" for user, workspace in _checked_out_by if workspace not in workspaces\n        ] if _checked_out_by else []\n        if checked_out_by:\n            message_text = f\"This file:\\n\\n{file_path_short}\\n\\nIs checked out by the following users:\\n\"\n            for user in checked_out_by:\n                message_text = f\"{message_text}\\n - {user}\"\n\n            sm_dialogs.show_message_box(message_text, title=\"Just To Let You Know\")\n\n    is_latest = _file_path.p4.is_latest\n    if not get_latest_on_load:\n        return True if is_latest is None else is_latest\n\n    prompt_pre_open = get_latest_on_load_behaviour == \"Prompt\"\n    if is_latest is False and prompt_pre_open:\n        get_latest_on_load = sm_dialogs.show_query_box(\n            f\"Would you like to get latest on this file:\\n\\n{file_path_short}\"\n        )\n\n    if get_latest_on_load and is_latest is False:\n        _file_path.p4.get_latest()\n        print(f\"Getting latest on this file:\\n - {_file_path}\")\n\n    if (not is_latest) and (not get_latest_on_load):\n        print(f\"This file is not the latest version:\\n - {_file_path}\")\n        return False\n\n    return True\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/p4_dcc.html#client.version_control.backends.perforce.api.p4_dcc.on_pre_save","title":"<code>on_pre_save(file_path, tool_name)</code>","text":"<p>Check if the given file exists on the server and if it is latest and checking it out if so, offering the appropriate prompts to the user during the process.</p> <pre><code>- `file_path`: The path to check.\n- `tool_name`: The name of the tool to run this operation for.\n    This allows the correct settings to be queried.\n</code></pre> <pre><code>`True` if the file is exists on the server, is latest\n    and has been checked out, `False` if not.\n</code></pre> Source code in <code>client/version_control/backends/perforce/api/p4_dcc.py</code> <pre><code>def on_pre_save(file_path: _PathTypes, tool_name: str) -&gt; bool:\n    \"\"\"\n    Check if the given file exists on the server and if it is latest\n    and checking it out if so, offering the appropriate prompts\n    to the user during the process.\n\n    Arguments:\n    ---------\n        - `file_path`: The path to check.\n        - `tool_name`: The name of the tool to run this operation for.\n            This allows the correct settings to be queried.\n\n    Returns:\n    --------\n        `True` if the file is exists on the server, is latest\n            and has been checked out, `False` if not.\n    \"\"\"\n\n    file_path = pathlib.Path(file_path)\n    file_path_short = f\"...{str(file_path).split('Art')[-1]}\"\n    checkout_on_save = tool_settings.get_setting(\n        tool_name, \"checkout_on_save\", default_setting_value=True\n    )\n\n    checkout_on_save_behaviour = tool_settings.get_setting(\n        tool_name, \"checkout_on_save_behaviour\", default_setting_value=\"Automatically\"\n    )\n    prompt_pre_save = checkout_on_save_behaviour == \"Prompt\"\n\n    if api.is_offline and checkout_on_save:\n        if os.access(file_path, os.R_OK, follow_symlinks=True):\n            return True\n\n        checkout_file = True\n        if prompt_pre_save:\n            checkout_file = sm_dialogs.show_query_box(\n                f\"Would you like to check this file out:\\n\\n{file_path_short}\"\n            )\n\n        if not checkout_file:\n            return False\n\n        sm_dialogs.show_message_box(\n            \"Peforce is offline, check out command is being added to the offline cache!\"\n        )\n        file_path.p4.checkout()\n        return True\n\n    if not checkout_on_save:\n        return False\n\n    if file_path.is_dir():\n        raise AttributeError(\"Not sure how this has happened, but you are trying to check a folder!\")\n\n    # @sharkmob-shea.richardson\n    # We get a single stat and query the values of the dict\n    # rather than running separate functions on the path.p4 interface.\n    # This will reduce the number of calls to the server by a fair amount:\n    stat = file_path.p4.get_stat()\n    exists_on_server = bool(stat)\n    if not exists_on_server:\n        return False\n\n    def _is_file_latest(data):\n        # type: (dict) -&gt; bool\n        valid_states = {\"add\", \"move/add\", \"edit\"}\n        if \"action\" in data and data[\"action\"] in valid_states:\n            return True\n        if \"headRev\" not in data:\n            return False\n        if \"haveRev\" not in data:\n            return False\n\n        return data[\"headRev\"] == data[\"haveRev\"]\n\n    is_latest = _is_file_latest(stat)\n    if not is_latest:\n        continue_process = sm_dialogs.show_query_box(\n            (\n                f\"This file is not the latest version:\\n\\n{file_path_short}\\n\\n\"\n                \"Continuing to get latest and then saving will override other peoples work.\\n\"\n                \"Are you sure you would like to override other peoples work?\"\n            )\n        )\n        if not continue_process:\n            return False\n\n        is_latest = file_path.p4.get_latest()\n\n    if not is_latest:\n        sm_dialogs.show_message_box(\"File is not latest - cannot save!\")\n        return False\n\n    checkout_file = True\n    is_checked_out = False\n    if \"otherAction\" in stat:\n        is_checked_out = \"edit\" in stat[\"otherAction\"]\n\n    elif \"action\" in stat:\n        action = stat[\"action\"]\n        is_checked_out = \"edit\" in action or \"add\" in action\n\n    warn_if_checked_out: bool = tool_settings.get_setting(\n        tool_name, \"save_warn_checked_out\", default_setting_value=True\n    )\n    if is_checked_out:\n        _checked_out_by = file_path.p4.checked_out_by\n        workspaces = set(p4.get_workspaces())\n        checked_out_by = [\n            f\"'{user}' in workspace: '{workspace}'\" for user, workspace in _checked_out_by if workspace not in workspaces\n        ] if _checked_out_by else []\n        if checked_out_by:\n            if \"headType\" in stat and \"+l\" in stat[\"headType\"]:\n                checked_out_by_str = \"\\n - \".join(checked_out_by)\n                sm_dialogs.show_message_box(\n                    (\n                        f\"This file is exclusively checked out by:\\n\\n - {checked_out_by_str}\\n\\n\"\n                        \"This means it cannot be checked out nor saved locally!\"\n                    )\n                )\n                return False\n\n            if warn_if_checked_out:\n                    message_text = f\"This file:\\n\\n{file_path_short}\\n\\nIs checked out by the following users:\\n\"\n                    for user in checked_out_by:\n                        message_text = f\"{message_text}\\n - {user}\"\n\n                    message_text = (\n                        f\"{message_text}\\n\\nChecking out and saving can result in lost work!\"\n                        \"\\nAre you sure you would you like to do this?\"\n                    )\n\n                    checkout_file = sm_dialogs.show_query_box(message_text)\n                    if not checkout_file:\n                        return False\n\n                    if checkout_file:\n                        sm_dialogs.show_message_box(\n                            (\n                                f\"Simultaneous file check outs are risky business!\\n\\n\"\n                                \"Be cautious so as to avoid loss of work!\"\n                            )\n                        )\n\n    if prompt_pre_save and not is_checked_out:\n        checkout_file = sm_dialogs.show_query_box(\n            f\"Would you like to check this file out:\\n\\n{file_path_short}\"\n        )\n\n    if checkout_file and not is_checked_out:\n        try:\n            if file_path.p4.checkout():\n                print(f\"Checked out file:\\n - {file_path}\")\n                return True\n        except p4_errors.P4ExclusiveCheckoutError as error:\n            sm_dialogs.show_query_box(str(error))\n\n    return False\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/p4_errors.html","title":"p4_errors","text":""},{"location":"autoapi/client/version_control/backends/perforce/api/p4_offline.html","title":"p4_offline","text":""},{"location":"autoapi/client/version_control/backends/perforce/api/p4_offline.html#client.version_control.backends.perforce.api.p4_offline.P4ConnectionManager","title":"<code>P4ConnectionManager</code>","text":"Source code in <code>client/version_control/backends/perforce/api/p4_offline.py</code> <pre><code>class P4ConnectionManager:\n    @property\n    def log(self):\n        if not hasattr(self, \"_log\"):\n            self._log = log.get_advanced_logger(__name__)\n\n        return self._log\n\n    def checkout(\n        self,\n        paths: Iterable[str],\n        change_description: str | None = None\n    ) -&gt; list[bool]:\n        result = []\n        writable_files = []\n        for path in paths:\n            path = st_api.path.NiftyPath(path)\n            path.chmod(stat.S_IWRITE)\n            is_writable = os.access(path, os.R_OK, follow_symlinks=True)\n            result.append(is_writable)\n            if is_writable:\n                writable_files.append(path)\n\n        return result\n\n    def revert(self, *args, **kwargs):\n        raise p4_errors.P4UnsafeOfflineCommandError(\"revert\")\n\n    def submit(self, *args, **kwargs):\n        raise p4_errors.P4UnsafeOfflineCommandError(\"submit\")\n\n    def reconcile_checkout(\n        self,\n        paths: Iterable[str],\n        change_description: str | None = None\n    ):\n        for path in paths:\n            path = st_api.path.NiftyPath(path)\n            path.chmod(stat.S_IREAD)\n            # is_writable = os.access(path, os.R_OK, follow_symlinks=True)\n\n        # return result\n\n    def run_function(self, function: Callable[..., Any], args: tuple[Any], kwargs: dict[str, Any]):\n        function_name = function.__name__.replace(\"_connect_\", \"\")\n        offline_function = getattr(self, function_name, None)  # type: Callable[..., Any] | None\n        result = offline_function(*args, **kwargs) if offline_function else None\n        self.cache_action(function_name, *args, **kwargs)\n        return result\n\n    def cache_action(self, action: str, *args: Any, **kwargs: Any):\n        actions = self.load_cache()\n        actions.append(\n            {\n                \"action\": action,\n                \"date\": str(datetime.datetime.now().strftime(\"%A: %d/%m/%y %H:%M\")),\n                \"id\": str(uuid.uuid1()),\n                \"args\": args,\n                \"kwargs\": kwargs\n            }\n        )\n        tool_settings.save_setting(\"p4_offline_cache\", \"actions\", actions)\n\n    def _reconcile(self, actions: list[dict[str, Any]] | None = None):\n        \"\"\"\n        Attempt to run all the cached actions from when the user was offline.\n        \"\"\"\n        from p4 import p4\n\n        actions = actions or tool_settings.get_setting(\n            \"p4_offline_cache\", \"actions\", default_setting_value=[]\n        )\n        if not actions:\n            raise RuntimeError(\"No cached actions found!\")\n\n        for data in actions:\n            action, _, _, args, kwargs = data.values()\n            self.log.info(f\"Running action: {action}\")\n            reconcile_function = getattr(self, f\"reconcile_{action}\", None)\n            if reconcile_function:\n                self.log.info(f\"Running reconcile_function: {reconcile_function.__name__}\")\n                reconcile_function(*args, **kwargs)\n            else:\n                self.log.warning(f\"No reconcile function found for action: {action}\")\n\n            p4_function = getattr(p4, action, None)\n            if not p4_function:\n                self.log.warning(f\"No p4 function found for action: {action}\")\n                continue\n\n            self.log.info(f\"Running p4_function: {p4_function.__name__}\")\n            result = p4_function(*args, **kwargs)\n            yield result\n\n    def get_reconcile_generator(self, actions: list[dict[str, Any]] | None = None):\n        return self._reconcile(actions=actions)\n\n    def reconcile(self, actions: list[dict[str, Any]] | None = None):\n        _reconcile = self._reconcile(actions=actions)\n        results = []\n        while True:\n            try:\n                result = next(_reconcile)\n                results.append(result)\n            except StopIteration:\n                break\n\n        return results\n\n    def load_cache(self) -&gt; dict[str, Any]:\n        return tool_settings.get_setting(\n            \"p4_offline_cache\", \"actions\", default_setting_value=[]\n        )\n\n    def save_cache(self, actions: list[dict[str, Any]]):\n        return tool_settings.save_setting(\"p4_offline_cache\", \"actions\", actions)\n\n    def delete_actions(self, actions: list[dict[str, Any]]):\n        actions_to_keep = []\n        action_ids_to_delete = (action[\"id\"]for action in actions)\n        for action in self.load_cache():\n            if action[\"id\"] in action_ids_to_delete:\n                continue\n            actions_to_keep.append(action)\n\n        self.save_cache(actions_to_keep)\n</code></pre>"},{"location":"autoapi/client/version_control/backends/perforce/api/p4_offline.html#client.version_control.backends.perforce.api.p4_offline.__getattr__","title":"<code>__getattr__(attribute_name)</code>","text":"<p>Custom getattr for this module that will return the method of the module level P4ConnectionManager.</p> <pre><code>This achieves two things:\n    1. Allows a single P4ConnectionManager to be used for one off calls\n        in the main thread, without the need to init a new P4ConnectionManager\n        for each call.\n    2. Reduces the boilerplate required to expose the calls of the single\n        P4ConnectionManager, whilst still making the functionality\n        accessible at the module level.\n\nArgs:\n    attribute_name (str): The name of the module level attribute to access.\n\nReturns:\n    Any: The accessed attribute.\n</code></pre> Source code in <code>client/version_control/backends/perforce/api/p4_offline.py</code> <pre><code>def __getattr__(attribute_name: str) -&gt; Any:\n    \"\"\"\n    Custom __getattr__ for this module that will return\n    the method of the module level P4ConnectionManager.\n\n        This achieves two things:\n            1. Allows a single P4ConnectionManager to be used for one off calls\n                in the main thread, without the need to init a new P4ConnectionManager\n                for each call.\n            2. Reduces the boilerplate required to expose the calls of the single\n                P4ConnectionManager, whilst still making the functionality\n                accessible at the module level.\n\n        Args:\n            attribute_name (str): The name of the module level attribute to access.\n\n        Returns:\n            Any: The accessed attribute.\n    \"\"\"\n\n    connection_manager = _get_connection_manager()\n    if hasattr(connection_manager, attribute_name):\n        return getattr(connection_manager, attribute_name)\n\n    _globals = globals()\n    if attribute_name in _globals:\n        return getattr(_globals, attribute_name)\n\n    raise AttributeError(f\"{__name__} has no attribute: {attribute_name}!\")\n</code></pre>"},{"location":"autoapi/client/version_control/changes_viewer/index.html","title":"changes_viewer","text":""},{"location":"autoapi/client/version_control/changes_viewer/index.html#client.version_control.changes_viewer.show","title":"<code>show(root=None, debug=False, parent=None)</code>","text":"<p>Display Change Viewer GUI</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Run in debug-mode, defaults to False</p> <code>False</code> <code>parent</code> <code>QObject</code> <p>When provided parent the interface to this QObject.</p> <code>None</code> Source code in <code>client/version_control/changes_viewer/window.py</code> <pre><code>def show(root=None, debug=False, parent=None):\n    \"\"\"Display Change Viewer GUI\n\n    Arguments:\n        debug (bool, optional): Run in debug-mode,\n            defaults to False\n        parent (QtCore.QObject, optional): When provided parent the interface\n            to this QObject.\n\n    \"\"\"\n\n    try:\n        module.window.close()\n        del module.window\n    except (RuntimeError, AttributeError):\n        pass\n\n    with qt_app_context():\n        window = ChangesWindows(parent)\n        window.show()\n\n        module.window = window\n\n        # Pull window to the front.\n        module.window.raise_()\n        module.window.activateWindow()\n</code></pre>"},{"location":"autoapi/client/version_control/changes_viewer/abstract.html","title":"abstract","text":""},{"location":"autoapi/client/version_control/changes_viewer/abstract.html#client.version_control.changes_viewer.abstract.ChangeListItem","title":"<code>ChangeListItem</code>","text":"<p>Item representing regular change list from Perforce.</p> <p>Parameters:</p> Name Type Description Default <code>change</code> <code>str</code> <p>id (number) of change</p> required <code>user</code> <code>str</code> <p>who submitted</p> required <code>desc</code> <code>str</code> <p>comment</p> required <code>time</code> <code>str</code> <p>when it was committed (timestamp)</p> required Source code in <code>client/version_control/changes_viewer/abstract.py</code> <pre><code>class ChangeListItem:\n    \"\"\"Item representing regular change list from Perforce.\n\n    Args:\n        change (str): id (number) of change\n        user (str): who submitted\n        desc (str): comment\n        time (str): when it was committed (timestamp)\n    \"\"\"\n\n    def __init__(self, change, user, desc, time):\n        self.change = change\n        self.user = user\n        self.desc = desc\n        self.time = time\n\n    def to_data(self):\n        return {\n            \"change\": self.change,\n            \"user\": self.user,\n            \"desc\": self.desc,\n            \"time\": self.time,\n        }\n\n    @classmethod\n    def from_data(cls, data):\n        return cls(**data)\n</code></pre>"},{"location":"autoapi/client/version_control/changes_viewer/control.html","title":"control","text":""},{"location":"autoapi/client/version_control/changes_viewer/control.html#client.version_control.changes_viewer.control.ChangesViewerController","title":"<code>ChangesViewerController</code>","text":"<p>This is a temporary controller for AYON.</p> <p>Goal of this controller is to provide a way to get current context.</p> Source code in <code>client/version_control/changes_viewer/control.py</code> <pre><code>class ChangesViewerController:\n    \"\"\"This is a temporary controller for AYON.\n\n    Goal of this controller is to provide a way to get current context.\n    \"\"\"\n\n    def __init__(self, launch_data, host=None):\n        if host is None:\n            host = registered_host()\n        self._host = host\n        self._current_project = launch_data[\"project_name\"]\n        self._current_folder_id = launch_data[\"folder_entity\"][\"id\"]\n\n        manager = AddonsManager()\n        version_control_addon = manager.get(\"version_control\")\n        self._version_control_addon = version_control_addon\n        self.enabled = version_control_addon and version_control_addon.enabled\n\n        task_entity = launch_data[\"task_entity\"]\n        workspace_profile_context = WorkspaceProfileContext(\n            folder_paths=launch_data[\"folder_path\"],\n            task_names=task_entity[\"name\"],\n            task_types=task_entity[\"taskType\"],\n        )\n\n        conn_info = self._version_control_addon.get_connection_info(\n            project_name=launch_data[\"project_name\"],\n            context=workspace_profile_context\n        )\n        self._conn_info = conn_info\n\n        self._event_system = self._create_event_system()\n\n    def emit_event(self, topic, data=None, source=None):\n        if data is None:\n            data = {}\n        self._event_system.emit(topic, data, source)\n\n    def register_event_callback(self, topic, callback):\n        self._event_system.add_callback(topic, callback)\n\n    def login(self):\n        if not self.enabled:\n            return\n\n        if not self._conn_info:\n            raise RuntimeError(\"Not collected conn_info\")\n\n        conn_info = self._conn_info\n        PerforceRestStub.login(\n            host=conn_info[\"host\"],\n            port=conn_info[\"port\"],\n            username=conn_info[\"username\"],\n            password=conn_info[\"password\"],\n            workspace_name=conn_info[\"workspace_name\"]\n        )\n\n    def get_changes(self):\n        return PerforceRestStub.get_changes()\n\n    def sync_to(self, change_id):\n        if not self.enabled:\n            return\n\n        if not self._conn_info:\n            raise RuntimeError(\"Not collected conn_info\")\n        conn_info = self._conn_info\n        self.login()\n        PerforceRestStub.login(\n            host=conn_info[\"host\"],\n            port=conn_info[\"port\"],\n            username=conn_info[\"username\"],\n            password=conn_info[\"password\"],\n            workspace_name=conn_info[\"workspace_name\"]\n        )\n        workspace_dir = PerforceRestStub.get_workspace_dir(\n            conn_info[\"workspace_name\"])\n        PerforceRestStub.sync_to_version(\n            f\"{workspace_dir}/...\", change_id)\n\n\n    def get_current_project_name(self):\n        return self._current_project\n\n    def get_current_folder_id(self):\n        return self._current_folder_id\n\n    def _create_event_system(self):\n        return QueuedEventSystem()\n</code></pre>"},{"location":"autoapi/client/version_control/changes_viewer/model.html","title":"model","text":""},{"location":"autoapi/client/version_control/changes_viewer/widgets.html","title":"widgets","text":""},{"location":"autoapi/client/version_control/changes_viewer/widgets.html#client.version_control.changes_viewer.widgets.ChangesDetailWidget","title":"<code>ChangesDetailWidget</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Table printing list of changes from Perforce</p> Source code in <code>client/version_control/changes_viewer/widgets.py</code> <pre><code>class ChangesDetailWidget(QtWidgets.QWidget):\n    \"\"\"Table printing list of changes from Perforce\"\"\"\n    sync_triggered = QtCore.Signal()\n\n    def __init__(self, controller, parent=None):\n        super().__init__(parent)\n\n        model = ChangesModel(controller=controller, parent=self)\n        proxy = CustomSortProxyModel()\n        proxy.setSourceModel(model)\n        proxy.setFilterCaseSensitivity(QtCore.Qt.CaseInsensitive)\n\n        changes_view = TreeView(self)\n        changes_view.setSelectionMode(\n            QtWidgets.QAbstractItemView.ExtendedSelection\n        )\n        changes_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)\n        changes_view.setSortingEnabled(True)\n        changes_view.setAlternatingRowColors(True)\n        changes_view.setModel(proxy)\n        changes_view.setIndentation(0)\n\n        changes_view.setColumnWidth(0, 70)\n        changes_view.setColumnWidth(1, 430)\n        changes_view.setColumnWidth(2, 100)\n        changes_view.setColumnWidth(3, 120)\n\n        time_delegate = PrettyTimeDelegate()\n        changes_view.setItemDelegateForColumn(3, time_delegate)\n\n        message_label_widget = QtWidgets.QLabel(self)\n\n        sync_btn = QtWidgets.QPushButton(\"Sync to\", self)\n\n        self._block_changes = False\n        self._editable = False\n        self._item_id = None\n\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.addWidget(changes_view, 1)\n        layout.addWidget(message_label_widget, 0,\n                         QtCore.Qt.AlignLeft | QtCore.Qt.AlignBottom)\n        layout.addWidget(sync_btn, 0, QtCore.Qt.AlignRight)\n\n        sync_btn.clicked.connect(self._on_sync_clicked)\n\n        self._model = model\n        self._controller = controller\n        self._changes_view = changes_view\n        self.sync_btn = sync_btn\n        self._thread = None\n        self._time_delegate = time_delegate\n        self._message_label_widget = message_label_widget\n\n    def reset(self):\n        self._model.refresh()\n\n    def _on_sync_clicked(self):\n        selection_model = self._changes_view.selectionModel()\n        current_index = selection_model.currentIndex()\n        if not current_index.isValid():\n            return\n\n        change_id = current_index.data(CHANGE_ROLE)\n\n        self._message_label_widget.setText(f\"Syncing to '{change_id}'...\")\n\n        self.sync_btn.setEnabled(False)\n        thread = SyncThread(self._controller, change_id)\n        thread.finished.connect(lambda: self._on_thread_finished(change_id))\n        thread.start()\n\n        self._thread = thread\n\n    def _on_thread_finished(self, change_id):\n        self._message_label_widget.setText(\n            f\"Synced to '{change_id}'. \"\n            \"Please close Viewer to continue.\"\n        )\n        self.sync_btn.setEnabled(True)\n</code></pre>"},{"location":"autoapi/client/version_control/changes_viewer/window.html","title":"window","text":""},{"location":"autoapi/client/version_control/changes_viewer/window.html#client.version_control.changes_viewer.window.show","title":"<code>show(root=None, debug=False, parent=None)</code>","text":"<p>Display Change Viewer GUI</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Run in debug-mode, defaults to False</p> <code>False</code> <code>parent</code> <code>QObject</code> <p>When provided parent the interface to this QObject.</p> <code>None</code> Source code in <code>client/version_control/changes_viewer/window.py</code> <pre><code>def show(root=None, debug=False, parent=None):\n    \"\"\"Display Change Viewer GUI\n\n    Arguments:\n        debug (bool, optional): Run in debug-mode,\n            defaults to False\n        parent (QtCore.QObject, optional): When provided parent the interface\n            to this QObject.\n\n    \"\"\"\n\n    try:\n        module.window.close()\n        del module.window\n    except (RuntimeError, AttributeError):\n        pass\n\n    with qt_app_context():\n        window = ChangesWindows(parent)\n        window.show()\n\n        module.window = window\n\n        # Pull window to the front.\n        module.window.raise_()\n        module.window.activateWindow()\n</code></pre>"},{"location":"autoapi/client/version_control/launch_hooks/index.html","title":"launch_hooks","text":""},{"location":"autoapi/client/version_control/launch_hooks/perforce/index.html","title":"perforce","text":""},{"location":"autoapi/client/version_control/launch_hooks/perforce/pre_load_sync_project.html","title":"pre_load_sync_project","text":"<p>Shows dialog to sync Unreal project</p> Requires <p>None</p> Provides <p>self.data[\"last_workfile_path\"]</p>"},{"location":"autoapi/client/version_control/launch_hooks/perforce/pre_load_sync_project.html#client.version_control.launch_hooks.perforce.pre_load_sync_project.SyncUnrealProject","title":"<code>SyncUnrealProject</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Show dialog for artist to sync to specific change list.</p> <p>It is triggered before Unreal launch as syncing inside would likely lead to locks. It is called before <code>pre_workfile_preparation</code> which is using self.data[\"last_workfile_path\"].</p> <p>It is expected that workspace would be created, connected and first version of project would be synced before.</p> Source code in <code>client/version_control/launch_hooks/perforce/pre_load_sync_project.py</code> <pre><code>class SyncUnrealProject(PreLaunchHook):\n    \"\"\"Show dialog for artist to sync to specific change list.\n\n    It is triggered before Unreal launch as syncing inside would likely\n    lead to locks.\n    It is called before `pre_workfile_preparation` which is using\n    self.data[\"last_workfile_path\"].\n\n    It is expected that workspace would be created, connected\n    and first version of project would be synced before.\n    \"\"\"\n\n    order = -5\n    app_groups = [\"unreal\"]\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        version_control_addon = self._get_enabled_version_control_addon()\n        if not version_control_addon:\n            self.log.info(\"Version control is not enabled, skipping\")\n            return\n\n        self.data[\"last_workfile_path\"] = self._get_unreal_project_path(\n            version_control_addon, self.data)\n\n        with qt_app_context():\n            changes_tool = ChangesWindows(launch_data=self.data)\n            changes_tool.show()\n            changes_tool.raise_()\n            changes_tool.activateWindow()\n            changes_tool.showNormal()\n\n            changes_tool.exec_()\n\n    def _get_unreal_project_path(self, version_control_addon, launch_data):\n        task_entity = launch_data[\"task_entity\"]\n        workspace_profile_context = WorkspaceProfileContext(\n            folder_paths=launch_data[\"folder_path\"],\n            task_names=task_entity[\"name\"],\n            task_types=task_entity[\"taskType\"],\n        )\n        conn_info = version_control_addon.get_connection_info(\n            project_name=self.data[\"project_name\"],\n            project_settings=launch_data[\"project_settings\"],\n            context=workspace_profile_context\n        )\n\n        if not conn_info or not conn_info[\"workspace_name\"]:\n            raise RuntimeError(f\"Cannot find workspace for this context.\")\n\n        PerforceRestStub.login(\n            host=conn_info[\"host\"],\n            port=conn_info[\"port\"],\n            username=conn_info[\"username\"],\n            password=conn_info[\"password\"],\n            workspace_name=conn_info[\"workspace_name\"])\n\n        workspace_dir = PerforceRestStub.get_workspace_dir(\n            workspace_name=conn_info[\"workspace_name\"])\n        if not os.path.exists(workspace_dir):\n            raise RuntimeError(f\"{workspace_dir} must exists for using version\"\n                               \" control\")\n        project_files = self._find_uproject_files(workspace_dir)\n        if len(project_files) != 1:\n            raise RuntimeError(\"Found unexpected number of projects \"\n                               f\"'{project_files}.\\n\"\n                               \"Expected only single Unreal project.\")\n        return project_files[0]\n\n    def _get_enabled_version_control_addon(self):\n        if is_version_control_enabled(self.data[\"project_settings\"]):\n            manager = AddonsManager()\n            return manager[\"version_control\"]\n        return None\n\n    def _find_uproject_files(self, start_dir):\n        \"\"\"\n        This function searches for files with the .uproject extension recursively\n        within a starting directory and its subdirectories.\n\n        Args:\n            start_dir: The starting directory from where the search begins.\n\n        Returns:\n            A list of full paths to all the found .uproject files.\n        \"\"\"\n        uproject_files = []\n        for dirpath, dirnames, filenames in os.walk(start_dir):\n            for filename in filenames:\n                if filename.endswith(\".uproject\"):\n                    uproject_files.append(os.path.join(dirpath, filename))\n        return uproject_files\n</code></pre>"},{"location":"autoapi/client/version_control/perforce_triggers/index.html","title":"perforce_triggers","text":""},{"location":"autoapi/client/version_control/perforce_triggers/change_submit_trigger.html","title":"change_submit_trigger","text":""},{"location":"autoapi/client/version_control/perforce_triggers/change_submit_trigger.html#client.version_control.perforce_triggers.change_submit_trigger.call_change_submit_endpoint","title":"<code>call_change_submit_endpoint(addon_name, addon_version, user, changelist, client, stream)</code>","text":"<p>Calls endpoint on AYON server to spawn event per submit</p> Source code in <code>client/version_control/perforce_triggers/change_submit_trigger.py</code> <pre><code>def call_change_submit_endpoint(\n        addon_name, addon_version, user, changelist, client, stream):\n    \"\"\"Calls endpoint on AYON server to spawn event per submit\"\"\"\n    url = f\"{AYON_SERVER_URL}/api/addons/{addon_name}/{addon_version}/change_submit\"\n\n    payload = {\n        \"payload_schema_version\": PAYLOAD_SCHEMA_VERSION,\n        \"user\": user,\n        \"changelist\": changelist,\n        \"client\": client,\n        \"stream\": stream\n    }\n    json_data = json.dumps(payload).encode('utf-8')\n\n    req = urllib.request.Request(url, data=json_data, headers=headers)\n    req.add_header('Content-Type', 'application/json; charset=utf-8')\n\n    # Send the request and get the response\n    with urllib.request.urlopen(req) as response:\n        response_body = response.read().decode()  # Read and decode the\n        print(response_body)\n</code></pre>"},{"location":"autoapi/client/version_control/perforce_triggers/change_submit_trigger.html#client.version_control.perforce_triggers.change_submit_trigger.get_addon_version","title":"<code>get_addon_version()</code>","text":"<p>Looks for latest version of ADDON_NAME</p> Source code in <code>client/version_control/perforce_triggers/change_submit_trigger.py</code> <pre><code>def get_addon_version():\n    \"\"\"Looks for latest version of ADDON_NAME\"\"\"\n    url = f\"{AYON_SERVER_URL}/api/addons?details=1\"\n    data = get_json_response_data(url, headers)\n\n    found_addon = None\n    for addon in data[\"addons\"]:\n        if addon[\"name\"] == ADDON_NAME:\n            found_addon = addon\n            break\n\n    if not found_addon:\n        print(f\"'{ADDON_NAME} is not installed on the server.\")\n        return 1\n\n    return list(found_addon[\"versions\"].keys())[-1]\n</code></pre>"},{"location":"autoapi/client/version_control/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/version_control/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/version_control/plugins/create/unreal/index.html","title":"unreal","text":""},{"location":"autoapi/client/version_control/plugins/create/unreal/changelist_metadata.html","title":"changelist_metadata","text":""},{"location":"autoapi/client/version_control/plugins/create/unreal/changelist_metadata.html#client.version_control.plugins.create.unreal.changelist_metadata.UnrealPublishCommit","title":"<code>UnrealPublishCommit</code>","text":"<p>               Bases: <code>UnrealBaseAutoCreator</code></p> <p>Auto creator to mark current version of project as published.</p> <p>It should store identification of latest submitchange to highlight it as \"publish\" version. (Not all submits are created equally.)</p> <p>This logic should be eventually moved to UnrealBaseAutoCreator class in unreal addon andd only be imported from there.</p> Source code in <code>client/version_control/plugins/create/unreal/changelist_metadata.py</code> <pre><code>class UnrealPublishCommit(UnrealBaseAutoCreator):\n    \"\"\"Auto creator to mark current version of project as published.\n\n    It should store identification of latest submitchange to highlight it as\n    \"publish\" version. (Not all submits are created equally.)\n\n    This logic should be eventually moved to UnrealBaseAutoCreator class in\n    unreal addon andd only be imported from there.\n    \"\"\"\n    identifier = \"io.ayon.creators.unreal.changelist_metadata\"\n    product_type = \"changelist_metadata\"\n    label = \"Publish Changelist Metadata\"\n\n    default_variant = \"Main\"\n\n    def create(self, options=None):\n        existing_instance = None\n        for instance in self.create_context.instances:\n            if instance.product_type == self.product_type:\n                existing_instance = instance\n                break\n\n        context = self.create_context\n        project_name = context.get_current_project_name()\n        folder_path = context.get_current_folder_path()\n        folder_entity = get_folder_by_path(project_name, folder_path)\n        task_entity = context.get_current_task_entity()\n        task_name = task_entity[\"name\"]\n        host_name = context.host_name\n        if existing_instance is None:\n\n            product_name = self.get_product_name(\n                project_name, folder_entity, task_entity, self.default_variant,\n                host_name\n            )\n\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": self.default_variant,\n                \"productName\": product_name\n            }\n\n            data.update(self.get_dynamic_data(\n                project_name,\n                folder_entity,\n                task_entity,\n                self.default_variant,\n                host_name,\n                None\n            ))\n\n            # TODO enable when Settings available\n            # if not self.active_on_create:\n            #     data[\"active\"] = False\n\n            new_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(new_instance)\n            instance_name = f\"{product_name}{self.suffix}\"\n\n            pub_instance = create_publish_instance(instance_name, self.root)\n            pub_instance.set_editor_property('add_external_assets', True)\n\n            imprint(f\"{self.root}/{instance_name}\",\n                    new_instance.data_to_store())\n\n            return pub_instance\n\n        elif (\n                existing_instance[\"folderPath\"] != folder_path\n                or existing_instance.get(\"task\") != task_name\n        ):\n            product_name = self.get_product_name(\n                project_name, folder_entity, task_entity, self.default_variant,\n                host_name\n            )\n            existing_instance[\"folderPath\"] = folder_path\n            existing_instance[\"task\"] = task_name\n            existing_instance[\"productName\"] = product_name\n</code></pre>"},{"location":"autoapi/client/version_control/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/version_control/plugins/publish/collect_latest_changelist.html","title":"collect_latest_changelist","text":"Requires <p>instance.context.data[\"version_control\"] - credentials instance.data[\"version_control\"] - instance based data for extractions</p> Provides <p>instance.data[\"version_control\"][\"change_info\"][\"user\"] - author of submit                                                [\"change\"] - id of submit                                                [\"desc\"] - description                                                [\"time\"] - when created</p>"},{"location":"autoapi/client/version_control/plugins/publish/collect_latest_changelist.html#client.version_control.plugins.publish.collect_latest_changelist.CollectLatestChangeList","title":"<code>CollectLatestChangeList</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Looks for latest change list to store it later.</p> Source code in <code>client/version_control/plugins/publish/collect_latest_changelist.py</code> <pre><code>class CollectLatestChangeList(pyblish.api.InstancePlugin):\n    \"\"\"Looks for latest change list to store it later.\"\"\"\n\n    label = \"Collect Latest Changelist\"\n    order = pyblish.api.CollectorOrder + 0.4995\n    targets = [\"local\"]\n\n    families = [\"changelist_metadata\"]\n\n    def process(self, instance):\n        if not instance.context.data.get(\"version_control\"):\n            self.log.info(\"No version control collected, skipping.\")\n            return\n\n        change_info = PerforceRestStub.get_last_change_list()\n        if not change_info:\n            self.log.info(\"No changelist was found, \"\n                          \"extraction of it not possible.\")\n\n        if not instance.data.get(\"version_control\"):\n            instance.data[\"version_control\"] = {}\n\n        usable_info = {}\n        usable_info[\"change\"] = change_info[\"change\"]\n        usable_info[\"user\"] = change_info[\"user\"]\n        usable_info[\"desc\"] = change_info[\"desc\"]\n        usable_info[\"time\"] = change_info[\"time\"]\n\n        instance.data[\"version_control\"][\"change_info\"] = usable_info\n\n        self.log.debug(f\"Latest changelist info: {usable_info}\")\n</code></pre>"},{"location":"autoapi/client/version_control/plugins/publish/collect_version_control.html","title":"collect_version_control","text":"Requires <p>instance.context.data[\"version_control\"] - connection info for VC</p> Provides <p>instance     -&gt; families ([])</p>"},{"location":"autoapi/client/version_control/plugins/publish/collect_version_control.html#client.version_control.plugins.publish.collect_version_control.CollectVersionControl","title":"<code>CollectVersionControl</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Mark instance to be submitted.</p> Source code in <code>client/version_control/plugins/publish/collect_version_control.py</code> <pre><code>class CollectVersionControl(pyblish.api.InstancePlugin):\n    \"\"\"Mark instance to be submitted.\"\"\"\n\n    label = \"Collect Version Control Submission Info\"\n    order = pyblish.api.CollectorOrder + 0.4992\n    targets = [\"local\"]\n\n    profiles = None\n\n    def process(self, instance):\n        conn_info = instance.context.data.get(\"version_control\")\n        if not conn_info:\n            self.log.info(\"No Version control set and enabled\")\n\n        if not self.profiles:\n            self.log.warning(\"No profiles present for adding \"\n                             \"version_control family\")\n            return\n\n        version_control_family = \"version_control\"\n\n        host_name = instance.context.data[\"hostName\"]\n        product_type = instance.data[\"productType\"]\n        task_name = instance.data.get(\"task\")\n\n        filtering_criteria = {\n            \"hosts\": host_name,\n            \"product_types\": product_type,\n            \"tasks\": task_name\n        }\n        profile = filter_profiles(\n            self.profiles,\n            filtering_criteria,\n            logger=self.log\n        )\n\n        add_version_control = False\n\n        if profile:\n            add_version_control = profile[\"add_version_control\"]\n\n        if not add_version_control:\n            return\n\n        families = instance.data.setdefault(\"families\", [])\n        if not version_control_family in families:\n            instance.data[\"families\"].append(version_control_family)\n\n        result_str = \"Adding\"\n        username = conn_info[\"username\"]\n        password = conn_info[\"password\"]\n\n        workspace_dir = PerforceRestStub.get_workspace_dir(\n            conn_info[\"workspace_name\"])\n\n        instance.data[\"version_control\"] = {}\n        instance.data[\"version_control\"][\"roots\"] = {\"work\": workspace_dir}\n        instance.data[\"version_control\"][\"username\"] = username\n        instance.data[\"version_control\"][\"password\"] = password\n        instance.data[\"version_control\"][\"template_name\"] = \\\n            profile[\"template_name\"]\n\n        self.log.debug(f\"{result_str} 'version_control' product_type \"\n                       f\"for instance with '{product_type}' product type.\")\n</code></pre>"},{"location":"autoapi/client/version_control/plugins/publish/collect_version_control_login.html","title":"collect_version_control_login","text":"Requires <p>none</p> Provides <p>context.data     -&gt; \"version_control\" ({})</p>"},{"location":"autoapi/client/version_control/plugins/publish/collect_version_control_login.html#client.version_control.plugins.publish.collect_version_control_login.CollectVersionControlLogin","title":"<code>CollectVersionControlLogin</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect connection info and login with it.</p> <p>Do not fail explicitly if version control connection info is missing. Not all artists need to have credentials, not all DCCs should use version control.</p> Source code in <code>client/version_control/plugins/publish/collect_version_control_login.py</code> <pre><code>class CollectVersionControlLogin(pyblish.api.ContextPlugin):\n    \"\"\"Collect connection info and login with it.\n\n    Do not fail explicitly if version control connection info is missing.\n    Not all artists need to have credentials, not all DCCs should use\n    version control.\n    \"\"\"\n\n    label = \"Collect Version Control Connection Info\"\n    order = pyblish.api.CollectorOrder + 0.4990\n    targets = [\"local\"]\n\n    def process(self, context):\n        project_name = context.data[\"projectName\"]\n        project_settings = context.data[\"project_settings\"]\n        if not is_version_control_enabled(project_settings):\n            self.log.info(\n                \"Version control addon is not enabled\"\n                f\" for project '{project_name}'\"\n            )\n            return\n\n        version_control = (\n            context.data.get(\"ayonAddonsManager\", {}).get(\"version_control\"))\n        conn_info = self._get_conn_info(\n            project_name, version_control, project_settings, context)\n\n        if not conn_info:\n            return\n\n        context.data[\"version_control\"] = conn_info\n\n        PerforceRestStub.login(\n            conn_info[\"host\"],\n            conn_info[\"port\"],\n            conn_info[\"username\"],\n            conn_info[\"password\"],\n            conn_info[\"workspace_name\"]\n        )\n\n        stream = PerforceRestStub.get_stream(\n            workspace_name=conn_info[\"workspace_name\"])\n        context.data[\"version_control\"][\"stream\"] = stream\n        self.log.debug(f\"stream::{stream}\")\n\n        workspace_dir = PerforceRestStub.get_workspace_dir(\n            workspace_name=conn_info[\"workspace_name\"])\n        context.data[\"version_control\"][\"workspace_dir\"] = workspace_dir\n\n    def _get_conn_info(\n        self,\n        project_name,\n        version_control,\n        project_settings,\n        context\n    ):\n        \"\"\"Gets and check credentials for version-control\n\n        Args:\n            project_name (str)\n            version_control (Union[AYONAddon, Any]): addon from AddonsManager\n            project_settings (Dict[str, Any]): Prepared project settings.\n\n        Returns:\n            dict[str, str]: Connection info or None if validation failed\n        \"\"\"\n        task_entity = context.data.get(\"taskEntity\")\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n\n        workspace_context = WorkspaceProfileContext(\n            folder_paths=context.data[\"folderPath\"],\n            task_names=task_name,\n            task_types=task_type\n        )\n        conn_info = version_control.get_connection_info(\n            project_name, project_settings, workspace_context)\n\n        missing_creds = False\n        if not all([\n            conn_info[\"username\"],\n            conn_info[\"password\"],\n            conn_info[\"workspace_name\"]\n        ]):\n            site_name = get_local_site_id()\n            sett_str = (\n                \"ayon+settings://version_control?project=\"\n                f\"{project_name}&amp;site={site_name}\"\n            )\n            self.log.warning(\n                \"Required credentials are missing. \"\n                f\"Please go to `{sett_str}` to fill it.\")\n            missing_creds = True\n\n        if not all([conn_info[\"host\"], conn_info[\"port\"]]):\n            sett_str = (\n                f\"ayon+settings://version_control?project={project_name}\"\n            )\n            self.log.warning(\n                \"Required version control settings are missing. \"\n                f\"Please ask your AYON admin to fill `{sett_str}`.\")\n            missing_creds = True\n\n        if missing_creds:\n            return None\n\n        return conn_info\n</code></pre>"},{"location":"autoapi/client/version_control/plugins/publish/extract_change_list_info.html","title":"extract_change_list_info","text":"Requires <p>instance.context.data[\"version_control\"][\"change_info\"] - info about     change list</p> Provides <p>new representation with name == \"changelist_metadata\"</p>"},{"location":"autoapi/client/version_control/plugins/publish/extract_change_list_info.html#client.version_control.plugins.publish.extract_change_list_info.ExtractChangeListInfo","title":"<code>ExtractChangeListInfo</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Store change list info into a json file to be integrated later.</p> Source code in <code>client/version_control/plugins/publish/extract_change_list_info.py</code> <pre><code>class ExtractChangeListInfo(publish.Extractor):\n    \"\"\"Store change list info into a json file to be integrated later.\"\"\"\n\n    order = publish.Extractor.order\n    label = \"Extract Change List Info\"\n    families = [\"changelist_metadata\"]\n    targets = [\"local\"]\n\n\n    def process(self, instance):\n        change_info = instance.data.get(\"version_control\", {}).get(\"change_info\")  # noqa\n        if not change_info:\n            self.log.warning(\"No change_list info collected, skipping.\")\n\n        staging_dir = tempfile.mkdtemp()\n\n        file_name = f\"{change_info['change']}.json\"\n        change_list_path = os.path.join(staging_dir, file_name)\n        with open(change_list_path, \"w\") as fp:\n            json.dump(change_info, fp)\n\n        repre_data = {\n            \"name\": \"changelist_metadata\",\n            \"ext\": \"json\",\n            \"files\": file_name,\n            \"stagingDir\": staging_dir\n        }\n\n        instance.data[\"representations\"].append(repre_data)\n</code></pre>"},{"location":"autoapi/client/version_control/plugins/publish/integrate_perforce.html","title":"integrate_perforce","text":""},{"location":"autoapi/client/version_control/plugins/publish/integrate_perforce.html#client.version_control.plugins.publish.integrate_perforce.IntegratePerforce","title":"<code>IntegratePerforce</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Integrate perforce items</p> Source code in <code>client/version_control/plugins/publish/integrate_perforce.py</code> <pre><code>class IntegratePerforce(pyblish.api.InstancePlugin):\n    \"\"\"Integrate perforce items\n    \"\"\"\n\n    label = \"Integrate Perforce items\"\n    order = pyblish.api.IntegratorOrder + 0.499\n    targets = [\"local\"]\n\n    families = [\"version_control\"]\n\n    def process(self, instance):\n        version_template_key = (\n            instance.data.get(\"version_control\", {})[\"template_name\"])\n        if not version_template_key:\n            raise RuntimeError(\"Instance data missing 'version_control[template_name]'\")   # noqa\n\n        if \"_\" in version_template_key:\n            template_area, template_name = version_template_key.split(\"_\")\n        else:\n            template_area = version_template_key\n            template_name = \"default\"\n        anatomy = instance.context.data[\"anatomy\"]\n        template = anatomy.templates_obj.templates[template_area][template_name]  # noqa\n        if not template:\n            raise RuntimeError(\"Anatomy is missing configuration for '{}'\".\n                               format(version_template_key))\n\n        template_file_path = os.path.join(template[\"directory\"],\n                                          template[\"file\"])\n        anatomy_data = copy.deepcopy(instance.data[\"anatomyData\"])\n        anatomy_data[\"root\"] = instance.data[\"version_control\"][\"roots\"]\n        # anatomy_data[\"output\"] = ''\n        # anatomy_data[\"frame\"] = ''\n        # anatomy_data[\"udim\"] = ''\n\n        for repre in instance.data[\"representations\"]:\n            anatomy_data[\"ext\"] = repre[\"ext\"]\n\n            version_control_path = StringTemplate.format_template(\n                template_file_path, anatomy_data\n            )\n\n            source_path = repre[\"published_path\"]\n\n            dirname = os.path.dirname(version_control_path)\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n\n            is_on_server = PerforceRestStub.exists_on_server(version_control_path)\n            actual_time = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n            comment = os.path.basename(version_control_path) + actual_time\n            if is_on_server:\n                if PerforceRestStub.is_checkouted(version_control_path):\n                    raise RuntimeError(\"{} is checkouted by someone already, \"\n                                       \"cannot commit right now.\".format(\n                                        version_control_path))\n                if not PerforceRestStub.checkout(version_control_path,\n                                                 comment):\n                    raise ValueError(\"File {} not checkouted\".\n                                     format(version_control_path))\n\n            shutil.copy(source_path, version_control_path)\n            if not is_on_server:\n                if not PerforceRestStub.add(version_control_path,\n                                            comment):\n                    raise ValueError(\"File {} not added to changelist\".\n                                     format(version_control_path))\n\n            if not PerforceRestStub.submit_change_list(comment):\n                raise ValueError(\"Changelist not submitted\")\n</code></pre>"},{"location":"autoapi/client/version_control/plugins/publish/validate_stream.html","title":"validate_stream","text":""},{"location":"autoapi/client/version_control/plugins/publish/validate_stream.html#client.version_control.plugins.publish.validate_stream.ValidateStream","title":"<code>ValidateStream</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates if Perforce stream is collected.</p> <p>Current Deadline implementation requires P4 depots to be of type 'stream' and workspace to be assigned to a stream</p> Source code in <code>client/version_control/plugins/publish/validate_stream.py</code> <pre><code>class ValidateStream(pyblish.api.InstancePlugin):\n    \"\"\"Validates if Perforce stream is collected.\n\n    Current Deadline implementation requires P4 depots to be of type 'stream'\n    and workspace to be assigned to a stream\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Validate P4 Stream\"\n    families = [\"changelist_metadata\"]\n    targets = [\"local\"]\n\n    def process(self, instance):\n        stream = instance.context.data[\"version_control\"][\"stream\"]\n\n        if not stream:\n            msg = (\n                \"Deadline implementation require depot with `streams`. \"\n                \"Please let your Perforce admin set up your workspace with \"\n                \"stream connected.\"\n            )\n            raise PublishValidationError(self, msg)\n</code></pre>"},{"location":"autoapi/client/version_control/plugins/publish/validate_workspace.html","title":"validate_workspace","text":""},{"location":"autoapi/client/version_control/plugins/publish/validate_workspace.html#client.version_control.plugins.publish.validate_workspace.ValidateWorkspaceDir","title":"<code>ValidateWorkspaceDir</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates if workspace_dir was collected and is valid.</p> <p>Used for committing to P4 directly from AYON.</p> Source code in <code>client/version_control/plugins/publish/validate_workspace.py</code> <pre><code>class ValidateWorkspaceDir(pyblish.api.InstancePlugin):\n    \"\"\"Validates if workspace_dir was collected and is valid.\n\n    Used for committing to P4 directly from AYON.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    label = \"Validate P4 workspace dir\"\n    families = [\"version_control\"]\n    targets = [\"local\"]\n\n\n    def process(self, instance):\n        # TODO implement multiple roots\n        workspace_dir = instance.data[\"version_control\"][\"roots\"][\"work\"]\n\n        if not workspace_dir or not os.path.exists(workspace_dir):\n            project_name = instance.context.data.get(\"projectName\")\n            msg = (\"Please provide your local folder for workspace in \"\n                   \"`ayon+settings://version_control/local_setting/workspace_dir?project={}`\".format(project_name))  # noqa\n            raise PublishXmlValidationError(self, msg)\n</code></pre>"},{"location":"autoapi/client/version_control/rest/index.html","title":"rest","text":""},{"location":"autoapi/client/version_control/rest/communication_server.html","title":"communication_server","text":""},{"location":"autoapi/client/version_control/rest/communication_server.html#client.version_control.rest.communication_server.WebServerThread","title":"<code>WebServerThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Listener for websocket rpc requests.</p> <p>It would be probably better to \"attach\" this to main thread (as for example Harmony needs to run something on main thread), but currently it creates separate thread and separate asyncio event loop</p> Source code in <code>client/version_control/rest/communication_server.py</code> <pre><code>class WebServerThread(threading.Thread):\n    \"\"\" Listener for websocket rpc requests.\n\n        It would be probably better to \"attach\" this to main thread (as for\n        example Harmony needs to run something on main thread), but currently\n        it creates separate thread and separate asyncio event loop\n    \"\"\"\n    def __init__(self, module, port, loop):\n        super(WebServerThread, self).__init__()\n        self.is_running = False\n        self.server_is_running = False\n        self.port = port\n        self.module = module\n        self.loop = loop\n        self.runner = None\n        self.site = None\n        self.tasks = []\n\n    def run(self):\n        self.is_running = True\n\n        try:\n            log.debug(\"Starting websocket server\")\n\n            self.loop.run_until_complete(self.start_server())\n\n            webserver_url = \"http://localhost:{}\".format(self.port)\n            log.info(\n                f\"Running Websocket server on URL:{webserver_url}\"\n            )\n            os.environ[\"PERFORCE_WEBSERVER_URL\"] = webserver_url\n\n            asyncio.ensure_future(self.check_shutdown(), loop=self.loop)\n\n            self.server_is_running = True\n            self.loop.run_forever()\n\n        except Exception:\n            log.warning(\n                \"Websocket Server service has failed\", exc_info=True\n            )\n        finally:\n            self.server_is_running = False\n            # optional\n            self.loop.close()\n\n        self.is_running = False\n        log.info(\"Websocket server stopped\")\n\n    async def start_server(self):\n        \"\"\" Starts runner and TCPsite \"\"\"\n        self.runner = web.AppRunner(self.module.app)\n        await self.runner.setup()\n        self.site = web.TCPSite(self.runner, \"localhost\", self.port)\n        await self.site.start()\n\n    def stop(self):\n        \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n        self.is_running = False\n\n    async def check_shutdown(self):\n        \"\"\" Future that is running and checks if server should be running\n            periodically.\n        \"\"\"\n        while self.is_running:\n            while self.tasks:\n                task = self.tasks.pop(0)\n                log.debug(\"waiting for task {}\".format(task))\n                await task\n                log.debug(\"returned value {}\".format(task.result))\n\n            await asyncio.sleep(0.5)\n\n        log.debug(\"## Server shutdown started\")\n\n        await self.site.stop()\n        log.debug(\"# Site stopped\")\n        await self.runner.cleanup()\n        log.debug(\"# Server runner stopped\")\n        tasks = [\n            task for task in asyncio.all_tasks()\n            if task is not asyncio.current_task()\n        ]\n        list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        log.debug(f\"Finished awaiting cancelled tasks, results: {results}...\")\n        await self.loop.shutdown_asyncgens()\n        # to really make sure everything else has time to stop\n        await asyncio.sleep(0.07)\n        self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/version_control/rest/communication_server.html#client.version_control.rest.communication_server.WebServerThread.check_shutdown","title":"<code>check_shutdown()</code>  <code>async</code>","text":"<p>Future that is running and checks if server should be running periodically.</p> Source code in <code>client/version_control/rest/communication_server.py</code> <pre><code>async def check_shutdown(self):\n    \"\"\" Future that is running and checks if server should be running\n        periodically.\n    \"\"\"\n    while self.is_running:\n        while self.tasks:\n            task = self.tasks.pop(0)\n            log.debug(\"waiting for task {}\".format(task))\n            await task\n            log.debug(\"returned value {}\".format(task.result))\n\n        await asyncio.sleep(0.5)\n\n    log.debug(\"## Server shutdown started\")\n\n    await self.site.stop()\n    log.debug(\"# Site stopped\")\n    await self.runner.cleanup()\n    log.debug(\"# Server runner stopped\")\n    tasks = [\n        task for task in asyncio.all_tasks()\n        if task is not asyncio.current_task()\n    ]\n    list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    log.debug(f\"Finished awaiting cancelled tasks, results: {results}...\")\n    await self.loop.shutdown_asyncgens()\n    # to really make sure everything else has time to stop\n    await asyncio.sleep(0.07)\n    self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/version_control/rest/communication_server.html#client.version_control.rest.communication_server.WebServerThread.start_server","title":"<code>start_server()</code>  <code>async</code>","text":"<p>Starts runner and TCPsite</p> Source code in <code>client/version_control/rest/communication_server.py</code> <pre><code>async def start_server(self):\n    \"\"\" Starts runner and TCPsite \"\"\"\n    self.runner = web.AppRunner(self.module.app)\n    await self.runner.setup()\n    self.site = web.TCPSite(self.runner, \"localhost\", self.port)\n    await self.site.start()\n</code></pre>"},{"location":"autoapi/client/version_control/rest/communication_server.html#client.version_control.rest.communication_server.WebServerThread.stop","title":"<code>stop()</code>","text":"<p>Sets is_running flag to false, 'check_shutdown' shuts server down</p> Source code in <code>client/version_control/rest/communication_server.py</code> <pre><code>def stop(self):\n    \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n    self.is_running = False\n</code></pre>"},{"location":"autoapi/client/version_control/rest/perforce/index.html","title":"perforce","text":""},{"location":"autoapi/client/version_control/rest/perforce/rest_api.html","title":"rest_api","text":""},{"location":"autoapi/client/version_control/rest/perforce/rest_api.html#client.version_control.rest.perforce.rest_api.PerforceModuleRestAPI","title":"<code>PerforceModuleRestAPI</code>","text":"<p>REST API endpoint used for Perforce operations</p> Source code in <code>client/version_control/rest/perforce/rest_api.py</code> <pre><code>class PerforceModuleRestAPI:\n    \"\"\"\n    REST API endpoint used for Perforce operations\n    \"\"\"\n\n    def __init__(self, server_manager):\n        self._log = None\n        self.server_manager = server_manager\n        self.prefix = \"/perforce\"\n\n    @property\n    def log(self):\n        if self._log is None:\n            self._log = Logger.get_logger(self.__class__.__name__)\n        return self._log\n\n    def register(self):\n        login = rest_routes.LoginEndpoint()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/login\",\n            login.dispatch\n        )\n\n        is_in_any_workspace = rest_routes.IsPathInAnyWorkspace()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/is_in_any_workspace\",\n            is_in_any_workspace.dispatch\n        )\n\n        add_file = rest_routes.AddEndpoint()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/add\",\n            add_file.dispatch\n        )\n\n        sync_latest_version = rest_routes.SyncLatestEndpoint()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/sync_latest_version\",\n            sync_latest_version.dispatch\n        )\n\n        sync_to_version = rest_routes.SyncVersionEndpoint()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/sync_to_version\",\n            sync_to_version.dispatch\n        )\n\n        checkout = rest_routes.CheckoutEndpoint()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/checkout\",\n            checkout.dispatch\n        )\n\n        is_checkouted = rest_routes.IsCheckoutedEndpoint()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/is_checkouted\",\n            is_checkouted.dispatch\n        )\n\n        get_changes = rest_routes.GetChanges()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/get_changes\",\n            get_changes.dispatch\n        )\n\n        get_last_change_list = rest_routes.GetLastChangelist()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/get_last_change_list\",\n            get_last_change_list.dispatch\n        )\n\n        submit_change_list = rest_routes.SubmitChangelist()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/submit_change_list\",\n            submit_change_list.dispatch\n        )\n\n        exists_on_server = rest_routes.ExistsOnServer()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/exists_on_server\",\n            exists_on_server.dispatch\n        )\n\n        get_stream = rest_routes.GetStreamEndpoint()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/get_stream\",\n            get_stream.dispatch\n        )\n\n        get_workspace_dir = rest_routes.GetWorkspaceDirEndpoint()\n        self.server_manager.add_route(\n            \"POST\",\n            self.prefix + \"/get_workspace_dir\",\n            get_workspace_dir.dispatch\n        )\n</code></pre>"},{"location":"autoapi/client/version_control/rest/perforce/rest_stub.html","title":"rest_stub","text":""},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/index.html#server.settings.VersionControlSettings","title":"<code>VersionControlSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Version Control Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class VersionControlSettings(BaseSettingsModel):\n    \"\"\"Version Control Project Settings.\"\"\"\n\n    enabled: bool = Field(default=False)\n\n    active_version_control_system: str = Field(\n        \"\",\n        enum_resolver=backend_enum,\n        title=\"Backend name\"\n    )\n\n    host_name: str = Field(\n        \"perforce\",\n        title=\"Host name\"\n    )\n\n    port: int = Field(\n        1666,\n        title=\"Port\"\n    )\n\n    publish: PublishPluginsModel = Field(\n        default_factory=PublishPluginsModel,\n        title=\"Publish Plugins\",\n    )\n\n    local_setting: LocalSubmodel = Field(\n        default_factory=LocalSubmodel,\n        title=\"Local setting\",\n        scope=[\"site\"],\n        description=\"This setting is only applicable for artist's site\",\n    )\n</code></pre>"},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.LocalSubmodel","title":"<code>LocalSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Provide artist based values</p> Source code in <code>server/settings/main.py</code> <pre><code>class LocalSubmodel(BaseSettingsModel):\n    \"\"\"Provide artist based values\"\"\"\n\n    username: str = Field(\n        \"\",\n        title=\"Username\",\n        scope=[\"site\"]\n    )\n    password: str = Field(\n        \"\",\n        title=\"Password\",\n        scope=[\"site\"]\n    )\n    workspace_profiles: list[WorkspaceProfileModel] = SettingsField(\n        default_factory=list,\n        scope=[\"site\"]\n    )\n</code></pre>"},{"location":"autoapi/server/settings/main.html#server.settings.main.VersionControlSettings","title":"<code>VersionControlSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Version Control Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class VersionControlSettings(BaseSettingsModel):\n    \"\"\"Version Control Project Settings.\"\"\"\n\n    enabled: bool = Field(default=False)\n\n    active_version_control_system: str = Field(\n        \"\",\n        enum_resolver=backend_enum,\n        title=\"Backend name\"\n    )\n\n    host_name: str = Field(\n        \"perforce\",\n        title=\"Host name\"\n    )\n\n    port: int = Field(\n        1666,\n        title=\"Port\"\n    )\n\n    publish: PublishPluginsModel = Field(\n        default_factory=PublishPluginsModel,\n        title=\"Publish Plugins\",\n    )\n\n    local_setting: LocalSubmodel = Field(\n        default_factory=LocalSubmodel,\n        title=\"Local setting\",\n        scope=[\"site\"],\n        description=\"This setting is only applicable for artist's site\",\n    )\n</code></pre>"}]}